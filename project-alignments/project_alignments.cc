/*
 * Copyright (c) 2022-2023 Tuukka Norri
 * This code is licensed under MIT license (see LICENSE for details).
 */

#include <chrono>
#include <iostream>
#include <libbio/algorithm/sorted_set_union.hh>
#include <libbio/dispatch/dispatch_caller.hh>
#include <libbio/fasta_reader.hh>
#include <libbio/file_handle.hh>
#include <libbio/file_handling.hh>
#include <libbio/log_memory_usage.hh>
#include <libbio/utility.hh>
#include <panvc3/alignment_projector.hh>
#include <panvc3/compressed_fasta_reader.hh>
#include <panvc3/sequence_buffer_store.hh>
#include <panvc3/spsc_queue.hh>
#include <panvc3/utility.hh>
#include <range/v3/algorithm/copy.hpp>
#include <range/v3/iterator/insert_iterators.hpp>
#include <range/v3/view/enumerate.hpp>
#include <range/v3/view/single.hpp>
#include <range/v3/view/take_exactly.hpp>
#include <range/v3/view/transform.hpp>
#include <seqan3/io/sam_file/all.hpp>
#include <syncstream>
#include "cmdline.h"

namespace chrono	= std::chrono;
namespace fs		= std::filesystem;
namespace lb		= libbio;
namespace ios		= boost::iostreams;
namespace rsv		= ranges::views;


using seqan3::operator""_tag;


namespace seqan3 {
	// SeqAn 3 does not yet have a definition for the OA tag.
	// (Check when updating, though.)
	template <> struct sam_tag_type <"OA"_tag> { typedef std::string type; };
}


namespace {

	typedef std::uint16_t						seqan3_sam_tag_type;
	typedef std::vector <seqan3_sam_tag_type>	seqan3_sam_tag_vector;
	
	constexpr inline std::size_t	QUEUE_SIZE{16};
	constexpr inline std::size_t	CHUNK_SIZE{4};

	constinit static auto const preserved_sam_tags{[]() constexpr {
		// Consider saving UQ.
		std::array retval{
			"AM"_tag,	// The smallest template-independent mapping quality in the template
			"AS"_tag,	// Alignment score generated by the aligner
			"BC"_tag,	// Barcode sequence identifying the sample
			"BZ"_tag,	// Phred quality of the unique molecular barcode bases in the OX tag
			"CB"_tag,	// Cell identifier
			"CO"_tag,	// Free-text comments
			"CR"_tag,	// Cellular barcode sequence bases (uncorrected)
			"CS"_tag,	// Color read sequence
			"CT"_tag,	// Complete read annotation tag, used for consensus annotation dummy features
			"CY"_tag,	// Phred quality of the cellular barcode sequence in the CR tag
			"E2"_tag,	// The 2nd most likely base calls
			"FZ"_tag,	// Flow signal intensities
			"LB"_tag,	// Library
			"MI"_tag,	// Molecular identifier; a string that uniquely identifies the molecule from which the record was derived
			"ML"_tag,	// Base modification problems
			"MM"_tag,	// Base modifications / methylation
			"OA"_tag,	// Original alignment
			"OQ"_tag,	// Original base quality
			"OX"_tag,	// Original unique molecular barcode bases
			"PG"_tag,	// Program
			"PU"_tag,	// Platform unit
			"QT"_tag,	// Phred quality of the sample barcode sequence in the BC tag
			"QX"_tag,	// Quality score of the unique molecular identifier in the RX tag
			"RX"_tag,	// Sequence bases of the (possibly corrected) unique molecular identifier
			"TS"_tag	// Transcript strand
		};

		// Make sure that the values are sorted.
		std::sort(retval.begin(), retval.end());
		
		return retval;
	}()};

	
	struct sam_tag_specification
	{
		seqan3_sam_tag_type	original_rname{};
		seqan3_sam_tag_type	original_pos{};
		seqan3_sam_tag_type	original_rnext{};
		seqan3_sam_tag_type	original_pnext{};
		seqan3_sam_tag_type	realn_query_ranges{};
		seqan3_sam_tag_type	realn_ref_ranges{};
		seqan3_sam_tag_type	rec_idx{};
	};


	// Convert a SeqAn 3 SAM tag to a std::array <char, N> where 2 ≤ N.
	// I don't think SeqAn 3 has this utility function.
	// Compare to operator""_tag() in <seqan3/io/sam_file/sam_tag_dictionary.hpp>.
	template <std::size_t t_size>
	constexpr void from_tag(seqan3_sam_tag_type const val, std::array <char, t_size> &buffer)
	requires (2 <= t_size)
	{
		char const char0(val / 256); // Narrowed automatically when () (not {}) are used.
		char const char1(val % 256);
		std::get <0>(buffer) = char0;
		std::get <1>(buffer) = char1;
	}
	
	
	// Convert a std::array <char, 2> to a SeqAn 3 SAM tag.
	constexpr seqan3_sam_tag_type to_tag(std::array <char, 2> const &buffer)
	{
		// The tag needs to match /|A-Za-z][A-Za-z0-9]/ (SAMv1, Section 1.5 The alignment section: optional fields),
		// so the values will not be negative.
		libbio_always_assert_lte(std::get <0>(buffer), 127);
		libbio_always_assert_lte(std::get <1>(buffer), 127);
		seqan3_sam_tag_type retval(std::get <0>(buffer)); // Narrows when () (not {}) are used.
		retval *= 256;
		retval += std::get <1>(buffer);
		return retval;
	}
	
	
	template <typename t_string>
	panvc3::msa_index::chr_entry_vector::const_iterator
	find_chr_entry_(panvc3::msa_index::chr_entry_vector const &entries, t_string const &chr_id)
	{
		panvc3::msa_index::chr_entry_cmp chr_cmp;
		auto const it(std::lower_bound(entries.begin(), entries.end(), chr_id, chr_cmp));
		if (entries.end() == it || it->chr_id != chr_id)
		{
			std::osyncstream(std::cerr) << "ERROR: Did not find an entry for chromosome ID “" << chr_id << "” in the MSA index." << std::endl;
			std::exit(EXIT_FAILURE);
		}

		return it;
	}
	
	
	template <typename t_string>
	panvc3::msa_index::chr_entry const &
	find_chr_entry(panvc3::msa_index::chr_entry_vector const &entries, t_string const &chr_id)
	{
		return *find_chr_entry_(entries, chr_id);
	}
	
	
	template <typename t_string>
	panvc3::msa_index::sequence_entry_vector::const_iterator
	find_sequence_entry_(panvc3::msa_index::sequence_entry_vector const &entries, t_string const &seq_id)
	{
		panvc3::msa_index::sequence_entry_cmp seq_cmp;
		auto const it(std::lower_bound(entries.begin(), entries.end(), seq_id, seq_cmp));
		if (entries.end() == it || it->seq_id != seq_id)
		{
			std::osyncstream(std::cerr) << "ERROR: Did not find an entry for sequence ID “" << seq_id << "” in the MSA index." << std::endl;
			std::exit(EXIT_FAILURE);
		}
		
		return it;
	}
	
	
	template <typename t_string>
	panvc3::msa_index::sequence_entry const &
	find_sequence_entry(panvc3::msa_index::sequence_entry_vector const &entries, t_string const &seq_id)
	{
		return *find_sequence_entry_(entries, seq_id);
	}


	struct alignment_statistics
	{
		std::size_t flags_not_matched{};
		std::size_t ref_id_missing{};
		std::size_t matched_reads{};
	};
	
	
	struct realigned_range
	{
		std::string		qname{};
		panvc3::range	range{};

		realigned_range(panvc3::range const &range_):
			range(range_)
		{
		}

		realigned_range(std::string const &qname_, panvc3::range const &range_):
			qname(qname_),
			range(range_)
		{
		}
		
		bool operator<(realigned_range const &other) const { return range.to_tuple() < other.range.to_tuple(); }
		bool operator==(realigned_range const &other) const { return range.to_tuple() == other.range.to_tuple(); }
	};

	typedef std::vector <realigned_range>	realigned_range_vector;
	
	// Precondition: the given range is sorted by range.location.
	realigned_range_vector::const_iterator find_first_overlapping(
		realigned_range_vector::const_iterator it,
		realigned_range_vector::const_iterator const end
	)
	{
		if (it == end)
			return end;
		
		auto it_(it);
		++it;
		for (; it != end; ++it)
		{
			auto const range_end(it_->range.location + it_->range.length);
			if (it->range.location < range_end)
				return it_;
			else if (range_end < it->range.location + it->range.length)
				it_ = it;
		}
		
		return end;
	}


	template <typename t_duration>
	std::ostream &log_duration(std::ostream &os, t_duration dur)
	{
	    typedef chrono::duration <std::uint64_t, std::ratio <3600 * 24>> day_type;
		auto const dd{chrono::duration_cast <day_type>(dur)};
		auto const hh{chrono::duration_cast <chrono::hours>(dur -= dd)};
		auto const mm{chrono::duration_cast <chrono::minutes>(dur -= hh)};
		auto const ss{chrono::duration_cast <chrono::seconds>(dur -= mm)};
		auto const ms{chrono::duration_cast <chrono::milliseconds>(dur -= ss)};

		bool should_print{false};
		auto const dd_(dd.count());
		if (dd_)
		{
			os << dd_ << " d, ";
			should_print = true;
		}

		auto const hh_(hh.count());
		if (should_print || hh_)
		{
			os << hh_ << " h, ";
			should_print = true;
		}

		auto const mm_(mm.count());
		if (should_print || mm_)
		{
			os << mm_ << " m, ";
			should_print = true;
		}

		auto const ss_(ss.count());
		if (should_print || ss_)
			os << ss_ << " s, ";

		os << ms.count() << " ms";

		return os;
	}


	typedef std::vector <std::size_t>	reference_id_mapping_type;


	enum class project_task_status
	{
		inactive,
		processing,
		finishing
	};
		

	template <typename t_input_processor>
	class project_task : public panvc3::alignment_projector_delegate
	{
		friend t_input_processor;

		typedef chrono::high_resolution_clock					clock_type;
		typedef clock_type::time_point							time_point;
		
	public:
		typedef typename t_input_processor::input_record_type	record_type;
		typedef std::array <record_type, CHUNK_SIZE>			record_array;
		typedef typename t_input_processor::tag_count_map		tag_count_map;

	protected:
		t_input_processor					*m_input_processor{};
		record_array						m_records;
		panvc3::alignment_projector			m_alignment_projector;
		tag_count_map						m_removed_tag_counts;
		realigned_range_vector				m_realigned_ranges;
		std::size_t							m_valid_records{};
		std::size_t							m_task_id{};
		std::size_t							m_last_rec_idx{};
		time_point							m_realignment_start_time{};
		std::uint64_t						m_realignment_time{};
		std::uint32_t						m_realigned_range_count{};
		std::uint32_t						m_realigned_range_total_length{};
		std::atomic <project_task_status>	m_status{}; // FIXME: make this conditional.
		bool								m_should_store_realigned_range_qnames{};
		
	public:
		project_task():
			m_alignment_projector(*this)
		{
		}

		bool is_full() const { return CHUNK_SIZE == m_valid_records; }
		bool empty() const { return 0 == m_valid_records; }
		record_type &next_record() { libbio_assert(project_task_status::inactive == m_status.load()); libbio_assert_lt(m_valid_records, m_records.size()); return m_records[m_valid_records++]; }
		auto alignment_records() { auto const st(m_status.load()); libbio_assert(project_task_status::processing == st || project_task_status::finishing == st); return m_records | rsv::take_exactly(m_valid_records); }
		auto alignment_records() const { auto const st(m_status.load()); libbio_assert(project_task_status::processing == st || project_task_status::finishing == st); return m_records | rsv::take_exactly(m_valid_records); }
		
		void process();
		void output();
		inline void reset(); 

		void alignment_projector_begin_realignment(panvc3::alignment_projector const &) override { m_realignment_start_time = clock_type::now(); }
		void alignment_projector_end_realignment(panvc3::alignment_projector const &) override;
	};


	lb::file_ostream open_stream_with_handle(lb::file_handle const &handle)
	{
		auto const fd(handle.get());
		if (-1 == fd)
			return {};
		return {fd, ios::never_close_handle};
	}
	
	
	// Declare some virtual functions in order to make assigning input_processor to a std::unique_ptr easier.
	struct input_processor_base
	{
		virtual ~input_processor_base() {}
		virtual void process_input() = 0;
		virtual void output_status() const = 0;
	};
	
	
	template <typename t_aln_input, typename t_aln_output>
	class input_processor final : public input_processor_base
	{
		static_assert(panvc3::is_power_of_2(QUEUE_SIZE));

		typedef chrono::steady_clock								clock_type; // For profiling.
		typedef clock_type::time_point								time_point;
		typedef clock_type::duration								duration_type;

	public:
		typedef t_aln_input											input_type;
		typedef t_aln_output										output_type;
		typedef std::remove_cvref_t <
			decltype(
				std::declval <t_aln_output>().header().ref_ids()
			)
		>															output_reference_ids_type;
		typedef typename input_type::record_type					input_record_type;
		typedef project_task <input_processor>						project_task_type;
		typedef std::map <seqan3_sam_tag_type, std::size_t>			tag_count_map;
		typedef panvc3::spsc_queue <project_task_type, QUEUE_SIZE>	queue_type;
		typedef lb::dispatch_ptr <dispatch_queue_t>					dispatch_queue_ptr;
		typedef lb::dispatch_ptr <dispatch_semaphore_t>				semaphore_ptr;
		typedef	void												(*exit_callback_type)(void);
		typedef panvc3::compressed_fasta_reader						fasta_reader;
		typedef fasta_reader::sequence_vector						sequence_vector;
		
	protected:
		panvc3::msa_index				m_msa_index;
		input_type						m_aln_input;
		output_type						m_aln_output;
		lb::file_handle					m_realn_range_handle; // Needs to be before m_realn_range_output due to deallocation order.
		lb::file_ostream				m_realn_range_output;

		fasta_reader					m_fasta_reader;
		panvc3::sequence_buffer_store	m_reference_buffer_store;
		
		dispatch_queue_ptr				m_output_dispatch_queue;
		exit_callback_type				m_exit_cb{};
		
		queue_type						m_task_queue{};

		time_point						m_start_time{};
		
		std::uint64_t					m_realignment_time{}; // nanoseconds
		std::atomic_uint32_t			m_current_rec_idx{};
		std::uint32_t					m_realigned_range_count{};
		std::uint32_t					m_realigned_range_total_length{};
		
		alignment_statistics			m_statistics;
		tag_count_map					m_removed_tag_counts;
		realigned_range_vector			m_realigned_ranges;
		realigned_range_vector			m_realigned_range_buffer;
		reference_id_mapping_type		m_ref_id_mapping;
		seqan3_sam_tag_vector			m_additional_preserved_tags;
		std::string						m_msa_ref_id;
		std::string						m_ref_id_separator;
		std::int32_t					m_gap_opening_cost{};
		std::int32_t					m_gap_extension_cost{};
		sam_tag_specification			m_sam_tag_identifiers{};
		std::uint16_t					m_status_output_interval{};
		bool							m_should_consider_primary_alignments_only{};
		bool							m_should_use_read_base_qualities{};
		bool							m_should_keep_duplicate_realigned_ranges{};
		bool							m_should_output_debugging_information{};
		bool							m_should_process_tasks_in_parallel{};
		
	public:
		template <
			typename t_msa_ref_id,
			typename t_ref_id_separator
		>
		input_processor(
			panvc3::msa_index			&&msa_index,
			t_aln_input					&&aln_input,
			t_aln_output				&&aln_output,
			fasta_reader				&&fasta_reader_,
			lb::file_handle				&&realn_range_handle,
			t_msa_ref_id				&&msa_ref_id,
			t_ref_id_separator			&&ref_id_separator,
			reference_id_mapping_type	&&ref_id_mapping,
			seqan3_sam_tag_vector		&&additional_preserved_tags,
			sam_tag_specification const	&tag_identifiers,
			std::int32_t				gap_opening_cost,
			std::int32_t				gap_extension_cost,
			std::uint16_t				status_output_interval,
			bool						should_consider_primary_alignments_only,
			bool						should_use_read_base_qualities,
			bool						should_keep_duplicate_realigned_ranges,
			bool						should_output_debugging_information,
			exit_callback_type			exit_cb
		):
			m_msa_index(std::move(msa_index)),
			m_aln_input(std::move(aln_input)),
			m_aln_output(std::move(aln_output)),
			m_realn_range_handle(std::move(realn_range_handle)),
			m_realn_range_output(open_stream_with_handle(m_realn_range_handle)),
			m_fasta_reader(std::move(fasta_reader_)),
			m_reference_buffer_store(m_aln_output.header().ref_ids().size()),
			m_output_dispatch_queue(dispatch_queue_create("fi.iki.tsnorri.panvc3.project-alignments.output-queue", DISPATCH_QUEUE_SERIAL)),
			m_exit_cb(exit_cb),
			m_ref_id_mapping(std::move(ref_id_mapping)),
			m_additional_preserved_tags(std::move(additional_preserved_tags)),
			m_msa_ref_id(std::forward <t_msa_ref_id>(msa_ref_id)),
			m_ref_id_separator(std::forward <t_ref_id_separator>(ref_id_separator)),
			m_gap_opening_cost(gap_opening_cost),
			m_gap_extension_cost(gap_extension_cost),
			m_sam_tag_identifiers(tag_identifiers),
			m_status_output_interval(status_output_interval),
			m_should_consider_primary_alignments_only(should_consider_primary_alignments_only),
			m_should_use_read_base_qualities(should_use_read_base_qualities),
			m_should_keep_duplicate_realigned_ranges(should_keep_duplicate_realigned_ranges),
			m_should_output_debugging_information(should_output_debugging_information)
		{
			for (auto &task : m_task_queue.values())
			{
				task.m_input_processor = this;
				task.m_should_store_realigned_range_qnames = m_should_output_debugging_information;
			}
		}
		
		void process_input() override;
		void output_records(project_task_type &task);
		void output_realigned_ranges(realigned_range_vector const &ranges, std::size_t const task_id = 0);
		void finish();

		void output_status() const override;

		std::uint64_t realignment_time() const { return m_realignment_time; }
		std::uint32_t realigned_range_count() const { return m_realigned_range_count; }
		std::uint32_t current_record_index() const { return m_current_rec_idx.load(std::memory_order_relaxed); }
		
		panvc3::msa_index &msa_index() { return m_msa_index; }
		panvc3::msa_index const &msa_index() const { return m_msa_index; }
		input_type &alignment_input() { return m_aln_input; }
		input_type const &alignment_input() const { return m_aln_input; }
		output_type &alignment_output() { return m_aln_output; }
		output_type const &alignment_output() const { return m_aln_output; }
		dispatch_queue_t output_dispatch_queue() { return *m_output_dispatch_queue; }
		std::string const &reference_id_separator() const { return m_ref_id_separator; }
		std::string const &msa_reference_id() const { return m_msa_ref_id; }
		reference_id_mapping_type const &reference_id_mapping() const { return m_ref_id_mapping; }
		sequence_vector const &output_reference_sequence(std::size_t const idx) const { return m_reference_buffer_store.buffer(idx).get(); }
		std::int32_t gap_opening_cost() const { return m_gap_opening_cost; }
		std::int32_t gap_extension_cost() const { return m_gap_extension_cost; }
		sam_tag_specification const &sam_tag_identifiers() const { return m_sam_tag_identifiers; }
		seqan3_sam_tag_vector const &additional_preserved_tags() const { return m_additional_preserved_tags; }
		bool should_use_read_base_qualities() const { return m_should_use_read_base_qualities; }
		bool should_keep_duplicate_realigned_ranges() const { return m_should_keep_duplicate_realigned_ranges; }
		bool should_process_tasks_in_parallel() const { return m_should_process_tasks_in_parallel; }
	};


	template <typename t_aln_input, typename t_aln_output>
	void input_processor <t_aln_input, t_aln_output>::output_status() const
	{
		auto const pp(clock_type::now());
		auto const running_time{pp - m_start_time};
		auto const rec_idx(current_record_index());
		auto const realigned_ranges(realigned_range_count());

		std::osyncstream cerr(std::cerr);
		lb::log_time(cerr) << "Time spent processing: ";
		log_duration(cerr, running_time);
		cerr << "; processed " << rec_idx << " records";

		if (rec_idx)
		{
			double secs_per_record(chrono::duration_cast <chrono::seconds>(running_time).count());
			secs_per_record /= rec_idx;
			cerr << " (in " << secs_per_record << " s / record)";
		}
		
		cerr << "; realigned " << realigned_ranges << " ranges";
		if (realigned_ranges)
		{
			auto const realn_time{chrono::nanoseconds(realignment_time())};
			cerr << " (in ";
			log_duration(cerr, realn_time);

			double ns_per_realn(chrono::duration_cast <chrono::nanoseconds>(realn_time).count());
			double mean_realn_length(m_realigned_range_total_length);
			ns_per_realn /= realigned_ranges;
			mean_realn_length /= realigned_ranges;
			cerr << ", " << ns_per_realn << " ns / realignment, mean length " << mean_realn_length << " characters)";
		}

		cerr << ".\n" << std::flush;
	}


	template <typename t_aln_input, typename t_aln_output>
	void input_processor <t_aln_input, t_aln_output>::process_input()
	{
		m_start_time = clock_type::now();

		if (m_realn_range_output.is_open())
		{
			if (m_should_output_debugging_information)
			{
				if (m_should_keep_duplicate_realigned_ranges)
					m_realn_range_output << "Location\tLength\tTask\tQNAME\n";
				else
					m_realn_range_output << "Location\tLength\tQNAME\n";
			}
			else
			{
				m_realn_range_output << "Location\tLength\n";
			}
		}
		
		static_assert(0 < QUEUE_SIZE);
		
		lb::dispatch_ptr <dispatch_group_t> dispatch_group(dispatch_group_create());
		auto parallel_dispatch_queue(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0));
		
		auto task_idx(m_task_queue.pop_index()); // Reserve one task.
		std::size_t task_id{};
		auto prev_status_logging_time(clock_type::now());
		for (auto &&[rec_idx, aln_rec] : rsv::enumerate(m_aln_input))
		{
			m_current_rec_idx.store(rec_idx, std::memory_order_relaxed);
			if (0 == (1 + rec_idx) % 10'000'000)
				lb::log_time(std::osyncstream(std::cerr)) << "Processed " << (1 + rec_idx) << " alignments…\n" << std::flush;

			if (m_status_output_interval)
			{
				auto const pp(clock_type::now());
				if (std::chrono::minutes(m_status_output_interval) <= chrono::duration_cast <chrono::minutes>(pp - prev_status_logging_time))
				{
					prev_status_logging_time = pp;
					output_status();
				}
			}

			auto const flags(aln_rec.flag());
			if (lb::to_underlying(flags & (
				seqan3::sam_flag::unmapped					|
				seqan3::sam_flag::failed_filter				|
				seqan3::sam_flag::duplicate					|
				seqan3::sam_flag::supplementary_alignment
			))) // Ignore unmapped, filtered, duplicate and supplementary.
			{
				++m_statistics.flags_not_matched;
				continue;
			}
			
			// Ignore secondary if requested.
			if (m_should_consider_primary_alignments_only && lb::to_underlying(flags & seqan3::sam_flag::secondary_alignment))
			{
				++m_statistics.flags_not_matched;
				continue;
			}
			
			auto const &ref_id(aln_rec.reference_id());
			if (!ref_id.has_value())
			{
				++m_statistics.ref_id_missing;
				continue;
			}
			
			auto const rec_ref_pos(aln_rec.reference_position());
			if (!rec_ref_pos.has_value())
			{
				++m_statistics.flags_not_matched;
				continue;
			}
			
			if (*rec_ref_pos < 0)
			{
				++m_statistics.flags_not_matched;
				continue;
			}
			
			++m_statistics.matched_reads;

			// Load the reference sequence if needed.
			{
				auto const dst_ref_id(m_ref_id_mapping[*ref_id]);
				auto const &dst_ref_names(m_aln_output.header().ref_ids());
				libbio_assert_lt(dst_ref_id, dst_ref_names.size());
				auto const &ref_name(dst_ref_names[dst_ref_id]);

				// Fill if needed.
				auto &ref_buffer(m_reference_buffer_store.acquire_buffer(dst_ref_id));
				auto &buffer(ref_buffer.get());
				if (buffer.empty())
				{
					lb::log_time(std::osyncstream(std::cerr)) << "(Re-)loading reference sequence '" << ref_name << "'…\n" << std::flush;
					if (!m_fasta_reader.read_sequence(ref_name, buffer))
					{
						std::osyncstream(std::cerr) << "ERROR: Unable to load sequence ‘" << ref_name << "’ from the input FASTA.\n" << std::flush;
						std::abort(); // spsc_queue’s semaphore is in use, so std::exit() can’t be called.
					}
					lb::log_time(std::osyncstream(std::cerr)) << "Loading complete.\n" << std::flush;
				}
			}
			
			// Check if records can be added to the current task.
			if (m_task_queue[task_idx].is_full())
			{
				// Recycle the buffers here.
				m_reference_buffer_store.recycle_buffers();

				// Process the current task.
				++task_id;
				auto &current_task(m_task_queue[task_idx]);
				current_task.m_task_id = task_id;
				current_task.m_status = project_task_status::processing;

				if (m_should_process_tasks_in_parallel)
					lb::dispatch(current_task).template group_async <&project_task_type::process>(*dispatch_group, parallel_dispatch_queue);
				else
					current_task.process();
				
				// Get an empty task.
				task_idx = m_task_queue.pop_index();
			}
			
			// Now there is guaranteed to be space in the current task.
			{
				auto &current_task(m_task_queue[task_idx]);
				libbio_assert(project_task_status::inactive == current_task.m_status.load());
				
#if 0
				using std::swap;
				swap(aln_rec, current_task.next_record());
				aln_rec.clear();
#else
				current_task.next_record() = aln_rec; // Copy.
#endif

				current_task.m_last_rec_idx = rec_idx;
			}
		}
		
		// Finish the last task if needed.
		{
			auto &last_task(m_task_queue[task_idx]);
			if (!last_task.empty())
			{
				++task_id;
				last_task.m_task_id = task_id;
				last_task.m_status = project_task_status::processing;
				if (m_should_process_tasks_in_parallel)
					lb::dispatch(last_task).template group_async <&project_task_type::process>(*dispatch_group, parallel_dispatch_queue);
				else
					last_task.process();
			}
		}
		
		// When all the work in the group has been completed,
		// the record output blocks have already been inserted to the serial queue.
		if (m_should_process_tasks_in_parallel)
			lb::dispatch(*this).template group_notify <&input_processor::finish>(*dispatch_group, *m_output_dispatch_queue);
		else
			finish();
	}


	template <typename t_input_processor>
	void project_task <t_input_processor>::reset()
	{
		m_valid_records = 0;
		m_removed_tag_counts.clear();
		m_realigned_ranges.clear();
		m_realigned_range_count = 0;
		m_realignment_time = 0;
		m_realigned_range_total_length = 0;
	}
	
	
	template <typename t_input_processor>
	void project_task <t_input_processor>::process()
	{
		typedef typename t_input_processor::input_type			input_type;
		typedef typename input_type::traits_type				input_traits_type;
		typedef typename input_traits_type::sequence_alphabet	sequence_alphabet;
		
		auto &output_header(m_input_processor->alignment_output().header());
		auto const &msa_index(m_input_processor->msa_index());
		auto const &ref_ids(m_input_processor->alignment_input().header().ref_ids()); // ref_ids() not const.
		auto const &ref_id_separator(m_input_processor->reference_id_separator());
		auto const &ref_id_mapping(m_input_processor->reference_id_mapping());
		auto const &tag_identifiers(m_input_processor->sam_tag_identifiers());
		auto const &additional_preserved_tags(m_input_processor->additional_preserved_tags());
		auto const gap_opening_cost(m_input_processor->gap_opening_cost());
		auto const gap_extension_cost(m_input_processor->gap_extension_cost());
		auto const should_use_read_base_qualities(m_input_processor->should_use_read_base_qualities());
		auto const should_keep_duplicate_realigned_ranges(m_input_processor->should_keep_duplicate_realigned_ranges());
		auto const should_process_tasks_in_parallel(m_input_processor->should_process_tasks_in_parallel());

		libbio_assert_eq(0, m_realignment_time);
		libbio_assert_eq(0, m_realigned_range_count);
		
		// Process the records.
		// Try to be efficient by caching the previous pointer.
		typedef typename input_type::ref_id_type		ref_id_type;
		typedef typename input_type::ref_offset_type	ref_offset_type_;	// std::optional <...>
		typedef typename ref_offset_type_::value_type	ref_offset_type;
		ref_id_type prev_ref_id{}; // std::optional.
		panvc3::msa_index::sequence_entry_vector::const_iterator src_seq_entry_it{};
		panvc3::msa_index::sequence_entry_vector::const_iterator dst_seq_entry_it{};
		std::stringstream oa_buffer;
		for (auto &aln_rec : alignment_records())
		{
			libbio_assert(project_task_status::processing == m_status.load());

			auto const &ref_id_(aln_rec.reference_id());
			libbio_assert(ref_id_.has_value());
			auto const ref_id(*ref_id_);
			
			// Check if we need to find the entries for this sequence.
			if (prev_ref_id != ref_id)
			{
				prev_ref_id = ref_id;
				std::string_view const ref_id_sv(ref_ids[ref_id]);
				
				auto const pos(ref_id_sv.find(ref_id_separator));
				if (pos == std::string_view::npos)
				{
					std::osyncstream(std::cerr) << "ERROR: Unable to find the separator “" << ref_id_separator << "” in the RNAME “" << ref_id_sv << "”." << std::endl;
					std::exit(EXIT_FAILURE);
				}
				
				auto const chr_id(ref_id_sv.substr(0, pos));
				auto const src_seq_id(ref_id_sv.substr(1 + pos));
				
				auto const &chr_entry(find_chr_entry(msa_index.chr_entries, chr_id));
				src_seq_entry_it = find_sequence_entry_(chr_entry.sequence_entries, src_seq_id);
				dst_seq_entry_it = find_sequence_entry_(chr_entry.sequence_entries, m_input_processor->msa_reference_id());
			}

			auto const dst_ref_id(ref_id_mapping[ref_id]);
			
			auto const &src_seq_entry(*src_seq_entry_it);
			auto const &dst_seq_entry(*dst_seq_entry_it);
			
			// Rewrite the CIGAR and the position.
			auto const src_pos(*aln_rec.reference_position());
			auto const &query_seq(aln_rec.sequence());
			auto const &cigar_seq(aln_rec.cigar_sequence());
			auto const &ref_seq(m_input_processor->output_reference_sequence(dst_ref_id));
			libbio_assert(!ref_seq.empty());
			
			m_alignment_projector.reset();
			auto const dst_pos(m_alignment_projector.project_alignment(
				src_pos,
				src_seq_entry,
				dst_seq_entry,
				ref_seq,
				query_seq,
				cigar_seq,
				aln_rec.base_qualities(),
				gap_opening_cost,
				gap_extension_cost
			));
			libbio_always_assert_lte_(dst_pos, std::numeric_limits <ref_offset_type>::max());

			// Copy the realigned ranges.
			auto const &realn_ranges(m_alignment_projector.realigned_reference_ranges());
			auto const realn_range_count(realn_ranges.size());
			if (realn_range_count)
			{
				m_realigned_ranges.reserve(m_realigned_ranges.size() + realn_range_count);

				if (m_should_store_realigned_range_qnames)
				{
					for (auto const &range : realn_ranges)
						m_realigned_ranges.emplace_back(aln_rec.id(), range);
				}
				else
				{
					for (auto const &range : realn_ranges)
						m_realigned_ranges.emplace_back(range);
				}
				
				if (!should_keep_duplicate_realigned_ranges)
				{
					// Sort by the range and remove duplicates.
					std::sort(m_realigned_ranges.begin(), m_realigned_ranges.end());
					m_realigned_ranges.erase(std::unique(m_realigned_ranges.begin(), m_realigned_ranges.end()), m_realigned_ranges.end());
				}
			}

			// Update the tags.
			auto &tags(aln_rec.tags());

			{
				typedef seqan3::sam_tag_type_t <"NM"_tag>	nm_type;
				std::optional <nm_type> original_nm;
				
				// Store the original NM value.
				{
					auto const it(tags.find("NM"_tag));
					if (tags.end() != it)
						original_nm = std::get <nm_type>(it->second);
				}

				// Remove the non-preserved tags.
				{
					auto it(tags.begin());
					auto const end(tags.end());
					
					while (it != end)
					{
						// Check if the current tag should be preserved.
						auto const tag(it->first);
						if (std::binary_search(preserved_sam_tags.begin(), preserved_sam_tags.end(), tag))
						{
							++it;
							continue;
						}

						if (std::binary_search(additional_preserved_tags.begin(), additional_preserved_tags.end(), tag))
						{
							++it;
							continue;
						}
						
						// Remove and increment the count.
						auto const it_(it);
						++it; // Not invalidated when std::map::erase() is called.
						tags.erase(it_);
						++m_removed_tag_counts[tag];
					}
				}

				// Store the original alignment.
				{
					using seqan3::get;

					// Clear the buffer.
					oa_buffer.str(std::string());
					oa_buffer.clear();

					// RNAME
					oa_buffer << ref_ids[ref_id] << ',';

					// POS
					oa_buffer << src_pos << ',';

					// Strand
					oa_buffer << (std::to_underlying(seqan3::sam_flag::on_reverse_strand & aln_rec.flag()) ? '-' : '+') << ',';

					// CIGAR
					for (auto const cc : cigar_seq)
					{
						oa_buffer << get <0>(cc);
						oa_buffer << get <1>(cc).to_char();
					}
					oa_buffer << ',';

					// MAPQ
					oa_buffer << +(aln_rec.mapping_quality()) << ',';

					// NM
					// The preceding comma is required even if the value is empty.
					if (original_nm)
						oa_buffer << *original_nm;

					// Trailing semicolon.
					oa_buffer << ';' << std::flush;

					// Copy to the end of OA.
					auto &oa_tag(tags.template get <"OA"_tag>());
					oa_tag += oa_buffer.view();
				}
			}
			
			// Store the re-aligned ranges.
			auto output_realn_ranges([realn_range_count, &tags](auto const &ranges, auto const tag){
				std::vector <std::uint32_t> output_ranges(2 * realn_range_count, 0);
				for (auto const &[idx, range] : rsv::enumerate(ranges))
				{
					auto const idx_(2 * idx);
					output_ranges[idx_] = range.location;
					output_ranges[idx_ + 1] = range.location + range.length;
				}
				tags[tag] = std::move(output_ranges);
			});
			if (tag_identifiers.realn_query_ranges && realn_range_count)
				output_realn_ranges(m_alignment_projector.realigned_query_ranges(), tag_identifiers.realn_query_ranges);
			if (tag_identifiers.realn_ref_ranges && realn_range_count)
				output_realn_ranges(m_alignment_projector.realigned_reference_ranges(), tag_identifiers.realn_ref_ranges);

			// Store the record index if needed.
			if (tag_identifiers.rec_idx)
			{
				auto const rec_idx(m_last_rec_idx - m_valid_records + 1);
				if (rec_idx <= INT32_MAX)
					tags[tag_identifiers.rec_idx] = std::int32_t(rec_idx);
			}

			// Original reference ID.
			if (tag_identifiers.original_rname)
				tags[tag_identifiers.original_rname] = ref_id;

			// Original position.
			if (tag_identifiers.original_pos)
				tags[tag_identifiers.original_pos] = src_pos;

			// Mate reference ID.
			auto const mate_ref_id(aln_rec.mate_reference_id());
			if (mate_ref_id)
			{
				aln_rec.mate_reference_id() = ref_id_mapping[*mate_ref_id];

				if (tag_identifiers.original_rnext)
					tags[tag_identifiers.original_rnext] = *mate_ref_id;
			}

			// Mate position.
			auto const mate_position_(aln_rec.mate_position());
			if (mate_position_)
			{
				auto const mate_position(*mate_position_);
				libbio_always_assert_lte(mate_position, std::numeric_limits <ref_offset_type>::max());
				auto const dst_mate_position(src_seq_entry.project_position(mate_position, dst_seq_entry));
				aln_rec.mate_position() = dst_mate_position;

				if (tag_identifiers.original_pnext)
					tags[tag_identifiers.original_pnext] = mate_position;
			}

			// Finally (esp. after setting OA/OC) update the CIGAR, the positions, the header pointer,
			// and RNAME and RNEXT.
			aln_rec.reference_position() = dst_pos;
			aln_rec.cigar_sequence() = m_alignment_projector.alignment();
			aln_rec.header_ptr() = &output_header;
			aln_rec.reference_id() = dst_ref_id;
		}
		
		// Continue in the output queue.
		libbio_assert(project_task_status::processing == m_status.load());
		m_status = project_task_status::finishing;
		if (should_process_tasks_in_parallel)
			lb::dispatch(*this).template async <&project_task::output>(m_input_processor->output_dispatch_queue());
		else
			output();
	}


	template <typename t_input_processor>
	void project_task <t_input_processor>::alignment_projector_end_realignment(panvc3::alignment_projector const &aln_projector)
	{
		auto const pp(clock_type::now());
		auto const diff(pp - m_realignment_start_time);
		m_realignment_time += chrono::duration_cast <chrono::nanoseconds>(diff).count();
		++m_realigned_range_count;

		auto const &indel_run_checker(aln_projector.indel_run_checker());
		auto const ref_range(indel_run_checker.reference_range()); // Has segment-relative position.
		auto const query_range(indel_run_checker.query_range());
		auto const length(std::max(ref_range.length, query_range.length));
		m_realigned_range_total_length += length;
	}
	
	
	template <typename t_input_processor>
	void project_task <t_input_processor>::output()
	{
		// Now we are in the correct thread and also able to pass parameters to functions
		// without calling malloc, since we do not need to call via libdispatch.
		libbio_assert(project_task_status::finishing == m_status.load());
		m_input_processor->output_records(*this);
	}
	
	
	template <typename t_aln_input, typename t_aln_output>
	void input_processor <t_aln_input, t_aln_output>::output_records(project_task_type &task)
	{
		// Not thread-safe; needs to be executed in a serial queue.
		
		libbio_assert(project_task_status::finishing == task.m_status.load());
		
		for (auto &aln_rec : task.alignment_records())
		{
			libbio_assert_eq(aln_rec.sequence().size(), aln_rec.base_qualities().size());
			auto const ref_id(aln_rec.reference_id());
			m_reference_buffer_store.release_buffer(*ref_id);
			m_aln_output.push_back(aln_rec); // Needs non-const aln_rec. (Not sure why.)
		}
		
		// Update the removed tag counts.
		// Could be done in O(m + n) time with a specialised merge instead of O(m log n) that we currently have.
		// (I don't think this is significant in any way.)
		for (auto const &kv : task.m_removed_tag_counts)
			m_removed_tag_counts[kv.first] += kv.second;
		
		// Handle the realigned ranges.
		auto const &task_realigned_ranges(task.m_realigned_ranges);
		if (m_realn_range_output.is_open())
		{
			if (m_should_keep_duplicate_realigned_ranges)
				output_realigned_ranges(task_realigned_ranges, task.m_task_id);
			else
			{
				// Merge in O(n + m) time since both vectors are already sorted.
				m_realigned_range_buffer.clear();
				m_realigned_range_buffer.reserve(m_realigned_ranges.size() + task_realigned_ranges.size());
				lb::sorted_set_union(m_realigned_ranges, task_realigned_ranges, std::back_inserter(m_realigned_range_buffer));
				
				using std::swap;
				swap(m_realigned_ranges, m_realigned_range_buffer);
			}
		}

		// Update statistics.
		m_realigned_range_count += task.m_realigned_range_count;
		m_realignment_time += task.m_realignment_time;
		m_realigned_range_total_length += task.m_realigned_range_total_length;
		
		// Clean up.
		task.reset();
		task.m_status = project_task_status::inactive;
		m_task_queue.push(task);
	}
	
	
	template <typename t_aln_input, typename t_aln_output>
	void input_processor <t_aln_input, t_aln_output>::output_realigned_ranges(realigned_range_vector const &ranges, std::size_t const task_id)
	{
		if (m_should_output_debugging_information)
		{
			if (m_should_keep_duplicate_realigned_ranges)
			{
				for (auto const &rr : ranges)
					m_realn_range_output << rr.range.location << '\t' << rr.range.length << '\t' << task_id << '\t' << rr.qname << '\n';
			}
			else
			{
				for (auto const &rr : ranges)
					m_realn_range_output << rr.range.location << '\t' << rr.range.length << '\t' << rr.qname << '\n';
			}
		}
		else
		{
			for (auto const &rr : ranges)
				m_realn_range_output << rr.range.location << '\t' << rr.range.length << '\n';
		}
	}
	
	
	template <typename t_aln_input, typename t_aln_output>
	void input_processor <t_aln_input, t_aln_output>::finish()
	{
		m_aln_output.get_stream() << std::flush;
		std::cout << std::flush;
		
		// Output the sorted realigned ranges if needed.
		if (m_realn_range_output.is_open())
		{
			if (!m_should_keep_duplicate_realigned_ranges)
				output_realigned_ranges(m_realigned_ranges);
			
			m_realn_range_output << std::flush;
		}
		
		lb::log_time(std::cerr) << "Done." << std::endl;
		
		// Output the statistics.
		std::cerr << "Matched reads:     " << m_statistics.matched_reads << '\n';
		std::cerr << "Ref. ID missing:   " << m_statistics.ref_id_missing << '\n';
		std::cerr << "Flags not matched: " << m_statistics.flags_not_matched << '\n';
		
		if (m_realn_range_output.is_open() && !m_should_keep_duplicate_realigned_ranges)
			std::cerr << "Re-aligned ranges: " << m_realigned_ranges.size() << '\n';
		
		if (m_removed_tag_counts.empty())
			std::cerr << "No tags removed.\n";
		else
		{
			std::cerr << "Removed tags:\n";
			std::array <char, 3> buffer{'\0', '\0', '\0'};
			for (auto const &kv : m_removed_tag_counts)
			{
				from_tag(kv.first, buffer);
				std::cerr << '\t' << buffer.data() << ": " << kv.second << '\n';
			}
		}
		
		// Clean up.
		(*m_exit_cb)();
	}
	
	
	std::unique_ptr <input_processor_base> s_input_processor;


	void do_exit(void *)
	{
		s_input_processor.reset();
		std::exit(EXIT_SUCCESS);
	}


	void do_exit_async()
	{
		dispatch_async_f(dispatch_get_main_queue(), nullptr, &do_exit);
	}


	template <
		typename t_output_ref_ids,		// Cannot get this easily from aln_output_header.
		typename t_aln_input_header,
		typename t_aln_output_header
	>
	void process_headers(
		t_aln_input_header &aln_input_header,		// ref_ids() is non-const.
		std::string const &ref_id_separator,
		std::string const &ref_seq_id,				// Projection target.
		char const * const ref_order_path,
		t_aln_output_header &aln_output_header,
		reference_id_mapping_type &ref_id_mapping	// From input to output.
	)
	{
		ref_id_mapping.clear();
		
		aln_output_header.comments = aln_input_header.comments;
		aln_output_header.read_groups = aln_input_header.read_groups;
		
		auto const &input_ref_ids(aln_input_header.ref_ids()); // By default std::deque <std::string>.
		ref_id_mapping.resize(input_ref_ids.size(), SIZE_MAX);
		
		auto const &input_ref_id_info(aln_input_header.ref_id_info);
		auto &output_ref_id_info(aln_output_header.ref_id_info);
		auto &output_ref_dict(aln_output_header.ref_dict);
		
		{
			std::map <std::string, std::size_t, lb::compare_strings_transparent> unique_ref_ids;
			std::vector <std::size_t> ref_seq_idxs; // Indices of the projection target sequences in the input.
			
			typedef std::pair <std::size_t, bool> output_ref_name_value;
			std::unordered_map <
				std::string,
				output_ref_name_value,
				lb::string_hash_transparent,
				lb::string_equal_to_transparent
			> output_ref_name_order;
			
			if (ref_order_path)
			{
				// Read the reference names.
				lb::file_istream stream;
				std::string buffer;
				
				lb::open_file_for_reading(ref_order_path, stream);
				std::size_t idx{};
				while (std::getline(stream, buffer))
				{
					auto const res(output_ref_name_order.emplace(buffer, output_ref_name_value(idx, false)));
					if (!res.second)
						std::cerr << "WARNING: Identifier ‘" << buffer << "’ specified in reference name order more than once.\n";
					++idx;
				}
			}
			
			// Determine the unique reference identifiers by splitting by the separator and taking the left parts,
			// also number them.
			{
				std::size_t next_output_ref_idx{output_ref_name_order.size()};
				for (auto const &[input_ref_idx, input_ref_id_] : rsv::enumerate(input_ref_ids))
				{
					std::string_view const input_ref_id(input_ref_id_);
					auto const separator_pos(input_ref_id.find_first_of(ref_id_separator));
					if (std::string_view::npos == separator_pos)
					{
						std::cerr << "ERROR: Separator '" << ref_id_separator << "' not found in reference ID '" << input_ref_id << "'.\n";
						std::exit(EXIT_FAILURE);
					}
					
					auto const chr_id(input_ref_id.substr(0, separator_pos));
					auto const seq_id(input_ref_id.substr(1 + separator_pos));
					auto const it(unique_ref_ids.find(chr_id));
					std::size_t output_ref_idx{};
					if (unique_ref_ids.end() == it)
					{
						// Try to find chr_id in the user-specified order.
						auto const it(output_ref_name_order.find(chr_id));
						if (output_ref_name_order.end() == it)
						{
							output_ref_idx = next_output_ref_idx;
							++next_output_ref_idx;
							
							if (!output_ref_name_order.empty())
								std::cerr << "WARNING: Output reference ID ‘" << chr_id << "’ not found in the output order, placing in the end.\n";
						}
						else
						{
							auto &val(it->second);
							output_ref_idx = val.first;
							val.second = true; // Mark used.
						}
						
						unique_ref_ids.emplace(chr_id, output_ref_idx);
						output_ref_dict.emplace(chr_id, output_ref_idx); // We could use this in place of unique_ref_ids but I'm not sure if it has a transparent key comparator.
					}
					else
					{
						// chr_id already known.
						output_ref_idx = it->second;
					}
					
					ref_id_mapping[input_ref_idx] = output_ref_idx;
					
					// Store the index for copying ref_id_info in case we found the projection target sequence.
					if (ref_seq_id == seq_id)
						ref_seq_idxs.push_back(input_ref_idx);
				}
			}
			
			// Copy the output reference identifiers to the header, handle ref_id_info.
			{
				t_output_ref_ids output_ref_ids;
				output_ref_ids.resize(unique_ref_ids.size());
				output_ref_id_info.resize(unique_ref_ids.size());
				for (auto const &kv : unique_ref_ids)
					output_ref_ids[kv.second] = std::move(kv.first);
				
				for (auto const &input_idx : ref_seq_idxs)
				{
					auto const output_idx(ref_id_mapping[input_idx]);
					output_ref_id_info[output_idx] = input_ref_id_info[input_idx];
				}
				
				aln_output_header.ref_ids() = std::move(output_ref_ids);
			}
			
			// Check if there were any identifiers in the input that were not used.
			for (auto const &kv : output_ref_name_order)
			{
				auto const &val(kv.second);
				if (!val.second)
					std::cerr << "WARNING: Identifier ‘" << kv.first << "’ was given in the output reference name order but was not found in the input.\n";
			}
		}
	}


	void process(gengetopt_args_info const &args_info)
	{
		libbio_assert(args_info.ref_id_separator_arg);
		
		// Sanity check.
		if (args_info.alignments_arg && args_info.bam_input_flag)
		{
			std::cerr << "ERROR: --bam-input has no effect when reading input from a file.\n";
			std::exit(EXIT_FAILURE);
		}
		
		// Open the SAM input.
		typedef seqan3::sam_file_input <> input_type;
		auto aln_input{[&](){
			auto const make_input_type([&]<typename t_fmt>(t_fmt &&fmt){
				if (args_info.alignments_arg)
				{
					fs::path const path(args_info.alignments_arg);
					return input_type(path);
				}
				else
				{
					return input_type(std::cin, std::forward <t_fmt>(fmt));
				}
			});

			if (args_info.bam_input_flag)
				return make_input_type(seqan3::format_bam{});
			else
				return make_input_type(seqan3::format_sam{});
		}()};

		auto &aln_input_header(aln_input.header()); // ref_ids() not const.
		auto const &input_ref_ids(aln_input_header.ref_ids());
		
		// Type aliases for input and output.
		typedef std::remove_cvref_t <decltype(input_ref_ids)>			ref_ids_type;
		typedef seqan3::sam_file_output <
			typename input_type::selected_field_ids,
			seqan3::type_list <seqan3::format_sam, seqan3::format_bam>,
			ref_ids_type
		>																output_type;

		std::regex const tag_regex{"^[XYZ][A-Za-z0-9]$"};
		std::regex const any_tag_regex{"^[A-Za-z0-9]{2}$"};
		auto const make_sam_tag([&tag_regex, &any_tag_regex](char const *tag, bool const should_allow_any = false) -> seqan3_sam_tag_type {
			if (!tag)
				return 0;

			if (!std::regex_match(tag, (should_allow_any ? any_tag_regex : tag_regex)))
			{
				std::cerr << "ERROR: The given tag '" << tag << "' does not match the expected format.\n";
				std::exit(EXIT_FAILURE);
			}

			std::array <char, 2> buffer{tag[0], tag[1]};
			return to_tag(buffer);
		});

		std::string ref_id_separator(args_info.ref_id_separator_arg);
		std::string reference_msa_id(args_info.reference_msa_id_arg);

		// SAM tag identifiers.
		sam_tag_specification const tag_identifiers{
			.original_rname{make_sam_tag(args_info.original_rname_tag_arg)},
			.original_pos{make_sam_tag(args_info.original_pos_tag_arg)},
			.original_rnext{make_sam_tag(args_info.original_rnext_tag_arg)},
			.original_pnext{make_sam_tag(args_info.original_pnext_tag_arg)},
			.realn_query_ranges{make_sam_tag(args_info.realigned_query_ranges_tag_arg)},
			.realn_ref_ranges{make_sam_tag(args_info.realigned_ref_ranges_tag_arg)},
			.rec_idx{make_sam_tag(args_info.record_index_tag_arg)}
		};

		// Additional preserved SAM tags.
		seqan3_sam_tag_vector additional_preserved_tags;
		for (unsigned int i(0); i < args_info.preserve_tag_given; ++i)
		{
			auto const tag_id(make_sam_tag(args_info.preserve_tag_arg[i], true));
			libbio_always_assert_neq(0, tag_id);
			additional_preserved_tags.push_back(tag_id);
		}
		std::sort(additional_preserved_tags.begin(), additional_preserved_tags.end());

		// Status output interval
		if (args_info.status_output_interval_arg < 0)
		{
			std::cerr << "ERROR: Status output interval must be non-negative.\n";
			std::exit(EXIT_FAILURE);
		}

		// Open the alignment output file.
		auto aln_output{[&](){
			// Make sure that aln_output has some header information.
			auto const make_output_type([&]<typename t_fmt>(t_fmt &&fmt){
				ref_ids_type empty_ref_ids;
				if (args_info.output_path_arg)
				{
					return output_type(
						fs::path{args_info.output_path_arg},
						std::move(empty_ref_ids),
						rsv::empty <std::size_t>()	// Reference lengths; the constructor expects a forward range.
					);
				}
				else
				{
					return output_type(
						std::cout,
						std::move(empty_ref_ids),
						rsv::empty <std::size_t>(),	// Reference lengths; the constructor expects a forward range.
						std::forward <t_fmt>(fmt)
					);
				}
			});

			if (args_info.output_bam_flag)
				return make_output_type(seqan3::format_bam{});
			else
				return make_output_type(seqan3::format_sam{});
		}()};

		// Headers.
		reference_id_mapping_type ref_id_mapping;
		process_headers <ref_ids_type>(
			aln_input_header,
			ref_id_separator,
			reference_msa_id,
			args_info.reference_order_input_arg,
			aln_output.header(),
			ref_id_mapping
		);

		// Open the realigned range output file if needed.
		lb::file_handle realigned_range_handle;
		if (args_info.output_realigned_ranges_arg)
			realigned_range_handle = lb::file_handle(lb::open_file_for_writing(args_info.output_realigned_ranges_arg, lb::writing_open_mode::CREATE));
		
		// Load the MSA index.
		panvc3::msa_index msa_index;
		lb::log_time(std::cerr) << "Loading the MSA index…\n";
		{
			lb::file_istream stream;
			lb::open_file_for_reading(args_info.msa_index_arg, stream);
			cereal::PortableBinaryInputArchive archive(stream);
			archive(msa_index);
		}
		
		// Load the reference sequences.
		lb::log_time(std::cerr) << "Loading the reference sequences…\n";
		panvc3::compressed_fasta_reader fasta_reader;
		fasta_reader.open_path(args_info.reference_arg);

		// Process the input.
		s_input_processor = std::make_unique <input_processor <input_type, output_type>>(
			std::move(msa_index),
			std::move(aln_input),
			std::move(aln_output),
			std::move(fasta_reader),
			std::move(realigned_range_handle),
			std::move(reference_msa_id),
			std::move(ref_id_separator),
			std::move(ref_id_mapping),
			std::move(additional_preserved_tags),
			tag_identifiers,
			args_info.gap_opening_cost_arg,
			args_info.gap_extension_cost_arg,
			args_info.status_output_interval_arg,
			false, // args_info.primary_only_flag,
			args_info.use_read_base_qualities_flag,
			args_info.keep_duplicate_ranges_flag,
			args_info.debugging_output_flag,
			&do_exit_async
		);
		
		lb::log_time(std::cerr) << "Processing the alignments…\n";
		lb::dispatch(*s_input_processor).template async <&input_processor_base::process_input>(dispatch_get_main_queue());
	}
}


extern "C" void panvc3_project_alignments(int argc, char **argv)
{
	gengetopt_args_info args_info;
	if (0 != cmdline_parser(argc, argv, &args_info))
		std::exit(EXIT_FAILURE);
	
	//lb::setup_allocated_memory_logging();

	std::ios_base::sync_with_stdio(false);	// Don't use C style IO after calling cmdline_parser.

	if (args_info.print_invocation_given)
	{
		std::cerr << "Invocation:";
		for (int i(0); i < argc; ++i)
			std::cerr << ' ' << argv[i];
		std::cerr << '\n';
	}

	if (args_info.print_pid_given)
		std::cerr << "PID: " << getpid() << '\n';
	
	process(args_info);
}
