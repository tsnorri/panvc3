/*
 * Copyright (c) 2022-2024 Tuukka Norri
 * This code is licensed under MIT license (see LICENSE for details).
 */

#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/max.hpp>
#include <boost/accumulators/statistics/mean.hpp>
#include <boost/accumulators/statistics/median.hpp>
#include <boost/accumulators/statistics/min.hpp>
#include <boost/accumulators/statistics/stats.hpp>
#include <chrono>
#include <iostream>
#include <libbio/algorithm/sorted_set_union.hh>
#include <libbio/fasta_reader.hh>
#include <libbio/file_handle.hh>
#include <libbio/file_handling.hh>
#include <libbio/log_memory_usage.hh>
#include <libbio/sam.hh>
#include <libbio/utility.hh>
#include <panvc3/alignment_projector.hh>
#include <panvc3/compressed_fasta_reader.hh>
#include <panvc3/dispatch.hh>
#include <panvc3/sam_tag.hh>
#include <panvc3/sequence_buffer_store.hh>
#include <panvc3/spsc_queue.hh>
#include <panvc3/utility.hh>
#include <range/v3/algorithm/copy.hpp>
#include <range/v3/iterator/insert_iterators.hpp>
#include <range/v3/view/enumerate.hpp>
#include <range/v3/view/single.hpp>
#include <range/v3/view/take_exactly.hpp>
#include <range/v3/view/transform.hpp>
#include <syncstream>
#include "cmdline.h"

namespace accs		= boost::accumulators;
namespace chrono	= std::chrono;
namespace dispatch	= panvc3::dispatch;
namespace fs		= std::filesystem;
namespace lb		= libbio;
namespace ios		= boost::iostreams;
namespace rsv		= ranges::views;
namespace sam		= libbio::sam;

using namespace libbio::sam::literals;


namespace {

	constexpr inline std::size_t	QUEUE_SIZE{16};
	constexpr inline std::size_t	CHUNK_SIZE{4};

	constinit static auto const preserved_sam_tags{[]() constexpr {
		// Consider saving UQ.
		std::array retval{
			"AM"_tag,	// The smallest template-independent mapping quality in the template
			"AS"_tag,	// Alignment score generated by the aligner
			"BC"_tag,	// Barcode sequence identifying the sample
			"BZ"_tag,	// Phred quality of the unique molecular barcode bases in the OX tag
			"CB"_tag,	// Cell identifier
			"CO"_tag,	// Free-text comments
			"CR"_tag,	// Cellular barcode sequence bases (uncorrected)
			"CS"_tag,	// Color read sequence
			"CT"_tag,	// Complete read annotation tag, used for consensus annotation dummy features
			"CY"_tag,	// Phred quality of the cellular barcode sequence in the CR tag
			"E2"_tag,	// The 2nd most likely base calls
			"FZ"_tag,	// Flow signal intensities
			"LB"_tag,	// Library
			"MI"_tag,	// Molecular identifier; a string that uniquely identifies the molecule from which the record was derived
			"ML"_tag,	// Base modification problems
			"MM"_tag,	// Base modifications / methylation
			"OA"_tag,	// Original alignment
			"OQ"_tag,	// Original base quality
			"OX"_tag,	// Original unique molecular barcode bases
			"PG"_tag,	// Program
			"PU"_tag,	// Platform unit
			"QT"_tag,	// Phred quality of the sample barcode sequence in the BC tag
			"QX"_tag,	// Quality score of the unique molecular identifier in the RX tag
			"RX"_tag,	// Sequence bases of the (possibly corrected) unique molecular identifier
			"TS"_tag	// Transcript strand
		};
		
		// Make sure that the values are sorted.
		std::sort(retval.begin(), retval.end());
		
		return retval;
	}()};
	
	
	typedef std::vector <panvc3::msa_index::sequence_entry const *>	sequence_entry_ptr_vector;

	
	struct sam_tag_specification
	{
		sam::tag_type	original_rname{};
		sam::tag_type	original_pos{};
		sam::tag_type	original_rnext{};
		sam::tag_type	original_pnext{};
		sam::tag_type	realn_query_ranges{};
		sam::tag_type	realn_ref_ranges{};
		sam::tag_type	rec_idx{};
	};


	template <typename t_string>
	panvc3::msa_index::chr_entry_vector::const_iterator
	find_chr_entry_(panvc3::msa_index::chr_entry_vector const &entries, t_string const &chr_id)
	{
		panvc3::msa_index::chr_entry_cmp chr_cmp;
		auto const it(std::lower_bound(entries.begin(), entries.end(), chr_id, chr_cmp));
		if (entries.end() == it || it->chr_id != chr_id)
		{
			std::osyncstream(std::cerr) << "ERROR: Did not find an entry for chromosome ID “" << chr_id << "” in the MSA index." << std::endl;
			std::exit(EXIT_FAILURE);
		}

		return it;
	}
	
	
	template <typename t_string>
	panvc3::msa_index::chr_entry const &
	find_chr_entry(panvc3::msa_index::chr_entry_vector const &entries, t_string const &chr_id)
	{
		return *find_chr_entry_(entries, chr_id);
	}
	
	
	template <typename t_string>
	panvc3::msa_index::sequence_entry_vector::const_iterator
	find_sequence_entry_(panvc3::msa_index::sequence_entry_vector const &entries, t_string const &seq_id)
	{
		panvc3::msa_index::sequence_entry_cmp seq_cmp;
		auto const it(std::lower_bound(entries.begin(), entries.end(), seq_id, seq_cmp));
		if (entries.end() == it || it->seq_id != seq_id)
		{
			std::osyncstream(std::cerr) << "ERROR: Did not find an entry for sequence ID “" << seq_id << "” in the MSA index." << std::endl;
			std::exit(EXIT_FAILURE);
		}
		
		return it;
	}
	
	
	template <typename t_string>
	panvc3::msa_index::sequence_entry const &
	find_sequence_entry(panvc3::msa_index::sequence_entry_vector const &entries, t_string const &seq_id)
	{
		return *find_sequence_entry_(entries, seq_id);
	}


	struct alignment_statistics
	{
		std::size_t flags_not_matched{};
		std::size_t ref_id_missing{};
		std::size_t seq_missing{};
		std::size_t matched_reads{};
	};
	
	
	struct realigned_range
	{
		std::string		qname{};
		panvc3::range	range{};

		realigned_range(panvc3::range const &range_):
			range(range_)
		{
		}

		realigned_range(std::string const &qname_, panvc3::range const &range_):
			qname(qname_),
			range(range_)
		{
		}
		
		bool operator<(realigned_range const &other) const { return range.to_tuple() < other.range.to_tuple(); }
		bool operator==(realigned_range const &other) const { return range.to_tuple() == other.range.to_tuple(); }
	};

	typedef std::vector <realigned_range>	realigned_range_vector;
	
	// Precondition: the given range is sorted by range.location.
	realigned_range_vector::const_iterator find_first_overlapping(
		realigned_range_vector::const_iterator it,
		realigned_range_vector::const_iterator const end
	)
	{
		if (it == end)
			return end;
		
		auto it_(it);
		++it;
		for (; it != end; ++it)
		{
			auto const range_end(it_->range.location + it_->range.length);
			if (it->range.location < range_end)
				return it_;
			else if (range_end < it->range.location + it->range.length)
				it_ = it;
		}
		
		return end;
	}


	typedef std::vector <std::size_t>	reference_id_mapping_type;


	enum class project_task_status
	{
		inactive,
		processing,
		finishing
	};
	
	
	lb::file_ostream open_stream_with_handle(lb::file_handle const &handle)
	{
		auto const fd(handle.get());
		if (-1 == fd)
			return {};
		return {fd, ios::never_close_handle};
	}
	
	
	// Declare some virtual functions in order to make assigning input_processor to a std::unique_ptr easier.
	struct input_processor_base
	{
		virtual ~input_processor_base() {}
		virtual void process_input() = 0;
		virtual void output_status() const = 0;
	};
	
	class input_processor;
	
	
	struct alignment_input
	{
		sam::file_handle_input_range_	input_range;
		sam::header						header;
		sam::reader						reader;
		
		explicit alignment_input(lb::file_handle &&fh):
			input_range(std::move(fh))
		{
			input_range.prepare();
		}
		
		
		template <typename t_cb>
		void read_records(t_cb &&cb) { reader.read_records(header, input_range, std::forward <t_cb>(cb)); }
	};
	
	
	struct alignment_output
	{
		lb::file_handle					handle;
		sam::header						header;
		
		explicit alignment_output(lb::file_handle &&fh):
			handle(std::move(fh))
		{
		}
	};
	
	
	// lb::file_ostream is not movable and so we unfortunately need this.
	struct alignment_output_ : public alignment_output
	{
		lb::file_ostream				stream{};
		
		explicit alignment_output_(alignment_output &&ao):
			alignment_output(std::move(ao))
		{
			lb::open_stream_with_file_handle(stream, handle);
		}
		
		void output_record(sam::record const &rec) { sam::output_record(stream, header, rec); stream << '\n'; }
	};
	
	
	
	typedef std::map <sam::tag_type, std::size_t>	tag_count_map;
	
	
	class project_task final : public panvc3::alignment_projector_delegate
	{
		friend class input_processor;
		
		typedef chrono::high_resolution_clock					clock_type;
		typedef clock_type::time_point							time_point;
		typedef panvc3::alignment_projector_libbio				alignment_projector_type;
		
	public:
		typedef std::array <sam::record, CHUNK_SIZE>			record_array;

	protected:
		input_processor						*m_input_processor{};
		record_array						m_records{};
		alignment_projector_type			m_alignment_projector;
		tag_count_map						m_removed_tag_counts;
		realigned_range_vector				m_realigned_ranges;
		std::size_t							m_valid_records{};
		std::size_t							m_task_id{};
		std::size_t							m_last_rec_idx{};
		time_point							m_realignment_start_time{};
		std::uint64_t						m_realignment_time{};
		std::uint64_t						m_execution_time{};
		std::uint32_t						m_realigned_range_count{};
		std::uint32_t						m_realigned_range_total_length{};
		std::atomic <project_task_status>	m_status{}; // FIXME: make this conditional.
		bool								m_should_store_realigned_range_qnames{};
		
	public:
		project_task():
			m_alignment_projector(*this)
		{
		}

		bool is_full() const { return CHUNK_SIZE == m_valid_records; }
		bool empty() const { return 0 == m_valid_records; }
		sam::record &next_record() { libbio_assert(project_task_status::inactive == m_status.load()); libbio_assert_lt(m_valid_records, m_records.size()); return m_records[m_valid_records++]; }
		auto alignment_records() { auto const st(m_status.load()); libbio_assert(project_task_status::processing == st || project_task_status::finishing == st); return m_records | rsv::take_exactly(m_valid_records); }
		auto alignment_records() const { auto const st(m_status.load()); libbio_assert(project_task_status::processing == st || project_task_status::finishing == st); return m_records | rsv::take_exactly(m_valid_records); }
		
		void process();
		void output();
		inline void reset(); 

		void alignment_projector_begin_realignment(panvc3::alignment_projector_base const &) override { m_realignment_start_time = clock_type::now(); }
		void alignment_projector_end_realignment(panvc3::alignment_projector_base const &) override;
	};
	
	
	// FIXME: Now that we are not (indirectly) calling pthread_exit() in main(), we could store some of the instance variables on the stack instead.
	class input_processor final : public input_processor_base
	{
		static_assert(panvc3::is_power_of_2(QUEUE_SIZE));

		typedef chrono::steady_clock								clock_type; // For profiling.
		typedef clock_type::time_point								time_point;
		typedef clock_type::duration								duration_type;

		typedef accs::accumulator_set <double, accs::stats <
			accs::tag::mean,
			accs::tag::median,
			accs::tag::min,
			accs::tag::max
		>>															execution_time_accumulator_type;

	public:
		typedef panvc3::spsc_queue <project_task, QUEUE_SIZE>		queue_type;
		typedef	void												(*exit_callback_type)(void);
		typedef panvc3::compressed_fasta_reader						fasta_reader;
		typedef fasta_reader::sequence_vector						sequence_vector;
		
	protected:
		panvc3::msa_index				m_msa_index;
		sequence_entry_ptr_vector		m_src_seq_entries;
		sequence_entry_ptr_vector		m_dst_seq_entries;
		struct alignment_input			m_aln_input;
		struct alignment_output_		m_aln_output;
		lb::file_handle					m_realn_range_handle; // Needs to be before m_realn_range_output due to deallocation order.
		lb::file_ostream				m_realn_range_output;

		fasta_reader					m_fasta_reader;
		panvc3::sequence_buffer_store	m_reference_buffer_store;
		
		dispatch::serial_queue			m_output_dispatch_queue;
		dispatch::group					m_group;
		exit_callback_type				m_exit_cb{};
		
		queue_type						m_task_queue{};

		time_point						m_start_time{};
		
		std::uint64_t					m_realignment_time{}; // nanoseconds
		std::atomic_uint32_t			m_current_rec_idx{};
		std::uint32_t					m_realigned_range_count{};
		std::uint32_t					m_realigned_range_total_length{};
		
		alignment_statistics			m_statistics;
		execution_time_accumulator_type	m_task_execution_time_acc;
		tag_count_map					m_removed_tag_counts;
		realigned_range_vector			m_realigned_ranges;
		realigned_range_vector			m_realigned_range_buffer;
		reference_id_mapping_type		m_ref_id_mapping;
		sam::tag_vector					m_additional_preserved_tags;
		std::string						m_msa_ref_id;
		std::string						m_ref_id_separator;
		std::int32_t					m_gap_opening_cost{};
		std::int32_t					m_gap_extension_cost{};
		sam_tag_specification			m_sam_tag_identifiers{};
		std::uint16_t					m_status_output_interval{};
		bool							m_verbose_status_output{};
		bool							m_should_output_debugging_information{};
		bool							m_should_consider_primary_alignments_only{};
		bool							m_should_use_read_base_qualities{};
		bool							m_should_keep_duplicate_realigned_ranges{};
		bool							m_should_process_tasks_in_parallel{true};
		
	public:
		template <
			typename t_msa_ref_id,
			typename t_ref_id_separator
		>
		input_processor(
			panvc3::msa_index				&&msa_index,
			sequence_entry_ptr_vector		&&src_seq_entries,
			sequence_entry_ptr_vector		&&dst_seq_entries,
			alignment_input					&&aln_input,
			alignment_output				&&aln_output,
			fasta_reader					&&fasta_reader_,
			lb::file_handle					&&realn_range_handle,
			t_msa_ref_id					&&msa_ref_id,
			t_ref_id_separator				&&ref_id_separator,
			reference_id_mapping_type		&&ref_id_mapping,
			sam::tag_vector					&&additional_preserved_tags,
			sam_tag_specification const		&tag_identifiers,
			std::int32_t					gap_opening_cost,
			std::int32_t					gap_extension_cost,
			std::uint16_t					status_output_interval,
			bool							verbose_status_output,
			bool							should_consider_primary_alignments_only,
			bool							should_use_read_base_qualities,
			bool							should_keep_duplicate_realigned_ranges,
			bool							should_output_debugging_information,
			exit_callback_type				exit_cb
		):
			m_msa_index(std::move(msa_index)),
			m_src_seq_entries(std::move(src_seq_entries)),
			m_dst_seq_entries(std::move(dst_seq_entries)),
			m_aln_input(std::move(aln_input)),
			m_aln_output(std::move(aln_output)),
			m_realn_range_handle(std::move(realn_range_handle)),
			m_realn_range_output(open_stream_with_handle(m_realn_range_handle)),
			m_fasta_reader(std::move(fasta_reader_)),
			m_reference_buffer_store(m_aln_output.header.reference_sequences.size()),
			m_output_dispatch_queue(dispatch::parallel_queue::shared_queue()),
			m_exit_cb(exit_cb),
			m_ref_id_mapping(std::move(ref_id_mapping)),
			m_additional_preserved_tags(std::move(additional_preserved_tags)),
			m_msa_ref_id(std::forward <t_msa_ref_id>(msa_ref_id)),
			m_ref_id_separator(std::forward <t_ref_id_separator>(ref_id_separator)),
			m_gap_opening_cost(gap_opening_cost),
			m_gap_extension_cost(gap_extension_cost),
			m_sam_tag_identifiers(tag_identifiers),
			m_status_output_interval(status_output_interval),
			m_verbose_status_output(verbose_status_output),
			m_should_output_debugging_information(should_output_debugging_information),
			m_should_consider_primary_alignments_only(should_consider_primary_alignments_only),
			m_should_use_read_base_qualities(should_use_read_base_qualities),
			m_should_keep_duplicate_realigned_ranges(should_keep_duplicate_realigned_ranges)
		{
			for (auto &task : m_task_queue.values())
			{
				task.m_input_processor = this;
				task.m_should_store_realigned_range_qnames = m_should_output_debugging_information;
			}
		}
		
		void process_input() override;
		void finish_task(project_task &task);
		void output_realigned_ranges(realigned_range_vector const &ranges, std::size_t const task_id = 0);
		void finish();

		void output_status() const override;

		std::uint64_t realignment_time() const { return m_realignment_time; }
		std::uint32_t realigned_range_count() const { return m_realigned_range_count; }
		std::uint32_t current_record_index() const { return m_current_rec_idx.load(std::memory_order_relaxed); }
		
		sequence_entry_ptr_vector const &src_seq_entries() const { return m_src_seq_entries; }
		sequence_entry_ptr_vector const &dst_seq_entries() const { return m_dst_seq_entries; }
		struct alignment_input &alignment_input() { return m_aln_input; }
		struct alignment_input const &alignment_input() const { return m_aln_input; }
		struct alignment_output_ &alignment_output() { return m_aln_output; }
		struct alignment_output_ const &alignment_output() const { return m_aln_output; }
		dispatch::serial_queue &output_dispatch_queue() { return m_output_dispatch_queue; }
		std::string const &reference_id_separator() const { return m_ref_id_separator; }
		std::string const &msa_reference_id() const { return m_msa_ref_id; }
		reference_id_mapping_type const &reference_id_mapping() const { return m_ref_id_mapping; }
		sequence_vector const &output_reference_sequence(std::size_t const idx) const { return m_reference_buffer_store.buffer(idx).get(); }
		std::int32_t gap_opening_cost() const { return m_gap_opening_cost; }
		std::int32_t gap_extension_cost() const { return m_gap_extension_cost; }
		sam_tag_specification const &sam_tag_identifiers() const { return m_sam_tag_identifiers; }
		sam::tag_vector const &additional_preserved_tags() const { return m_additional_preserved_tags; }
		bool should_use_read_base_qualities() const { return m_should_use_read_base_qualities; }
		bool should_keep_duplicate_realigned_ranges() const { return m_should_keep_duplicate_realigned_ranges; }
		bool should_process_tasks_in_parallel() const { return m_should_process_tasks_in_parallel; }

		dispatch::group &dispatch_group() { return m_group; }
	};
	
	
	void input_processor::output_status() const
	{
		auto const pp(clock_type::now());
		auto const running_time{pp - m_start_time};
		auto const rec_idx(current_record_index());
		auto const realigned_ranges(realigned_range_count());

		std::osyncstream cerr(std::cerr);
		lb::log_time(cerr) << "Time spent processing: ";
		panvc3::log_duration(cerr, running_time);
		cerr << "; processed " << rec_idx << " records";

		if (rec_idx)
		{
			double usecs_per_record(chrono::duration_cast <chrono::microseconds>(running_time).count());
			usecs_per_record /= rec_idx;
			cerr << " (in " << usecs_per_record << " μs / record)";
		}
		
		cerr << "; realigned " << realigned_ranges << " ranges";
		if (realigned_ranges)
		{
			auto const realn_time{chrono::nanoseconds(realignment_time())};
			cerr << " (in ";
			panvc3::log_duration(cerr, realn_time);

			double usecs_per_realn(chrono::duration_cast <chrono::microseconds>(realn_time).count());
			double mean_realn_length(m_realigned_range_total_length);
			usecs_per_realn /= realigned_ranges;
			mean_realn_length /= realigned_ranges;
			cerr << "; " << usecs_per_realn << " µs / realignment, mean length " << mean_realn_length << " characters)";
		}

		cerr << '.';

		if (m_verbose_status_output)
		{
			cerr
				<< " Mean task execution time: " << (accs::mean(m_task_execution_time_acc) / 1000.0) << " µs"
				<< " median: " << (accs::median(m_task_execution_time_acc) / 1000.0) << " µs"
				<< " min: " << (accs::min(m_task_execution_time_acc) / 1000.0) << " µs"
				<< " max: " << (accs::max(m_task_execution_time_acc) / 1000.0) << " µs"
				<< '.';
		}

		cerr << '\n' << std::flush;
	}


	void input_processor::process_input()
	{
		m_start_time = clock_type::now();

		if (m_realn_range_output.is_open())
		{
			if (m_should_output_debugging_information)
			{
				if (m_should_keep_duplicate_realigned_ranges)
					m_realn_range_output << "Location\tLength\tTask\tQNAME\n";
				else
					m_realn_range_output << "Location\tLength\tQNAME\n";
			}
			else
			{
				m_realn_range_output << "Location\tLength\n";
			}
		}
		
		// Output the header.
		m_aln_output.stream << m_aln_output.header;
		
		static_assert(0 < QUEUE_SIZE);
		
		auto &parallel_dispatch_queue(dispatch::parallel_queue::shared_queue());
		
		auto task_idx(m_task_queue.pop_index()); // Reserve one task.
		std::size_t task_id{};
		auto prev_status_logging_time(clock_type::now());
		
		std::size_t rec_idx{};
		m_aln_input.read_records(
			[
				this,
				&parallel_dispatch_queue,
				&prev_status_logging_time,
				&rec_idx,
				&task_id,
				&task_idx
			](sam::record &aln_rec)
			{
				{
					m_current_rec_idx.store(rec_idx, std::memory_order_relaxed);
					if (0 == (1 + rec_idx) % 10'000'000)
						lb::log_time(std::osyncstream(std::cerr)) << "Processed " << (1 + rec_idx) << " alignments…\n" << std::flush;
					
					{
						auto const pp(clock_type::now());
						if (std::chrono::minutes(m_status_output_interval) <= chrono::duration_cast <chrono::minutes>(pp - prev_status_logging_time))
						{
							prev_status_logging_time = pp;
							output_status();
						}
					}

					auto const flags(aln_rec.flag);
					if (lb::to_underlying(flags & (
						sam::flag::unmapped			|
						sam::flag::failed_filter	|
						sam::flag::duplicate
					))) // Ignore unmapped, filtered, and duplicate. (BWA may set supplementary to non-chimeric?)
					{
						++m_statistics.flags_not_matched;
						goto finish;
					}
			
					// Ignore secondary and supplementary if requested.
					if (m_should_consider_primary_alignments_only && lb::to_underlying(flags & sam::flag::secondary_alignment))
					{
						++m_statistics.flags_not_matched;
						goto finish;
					}
					
					if (sam::INVALID_REFERENCE_ID == aln_rec.rname_id)
					{
						++m_statistics.ref_id_missing;
						goto finish;
					}
			
					if (sam::INVALID_POSITION == aln_rec.pos)
					{
						++m_statistics.flags_not_matched;
						goto finish;
					}
					
					if (aln_rec.seq.empty())
					{
						++m_statistics.seq_missing;
						goto finish;
					}
					
					++m_statistics.matched_reads;

					// Load the reference sequence if needed.
					{
						libbio_assert_lt(aln_rec.rname_id, m_ref_id_mapping.size());
						auto const dst_ref_id(m_ref_id_mapping[aln_rec.rname_id]);
						auto const &dst_ref_names(m_aln_output.header.reference_sequences);
						libbio_assert_lt(dst_ref_id, dst_ref_names.size());
						auto const &ref_name(dst_ref_names[dst_ref_id].name);

						// Fill if needed.
						auto &ref_buffer(m_reference_buffer_store.acquire_buffer(dst_ref_id));
						auto &buffer(ref_buffer.get());
						if (buffer.empty())
						{
							lb::log_time(std::osyncstream(std::cerr)) << "(Re-)loading reference sequence '" << ref_name << "'…\n" << std::flush;
							if (!m_fasta_reader.read_sequence(ref_name, buffer))
							{
								std::osyncstream(std::cerr) << "ERROR: Unable to load sequence ‘" << ref_name << "’ from the input FASTA.\n" << std::flush;
								std::abort(); // spsc_queue’s semaphore is in use, so std::exit() can’t be called.
							}
							lb::log_time(std::osyncstream(std::cerr)) << "Loading complete.\n" << std::flush;
						}
					}
			
					// Check if records can be added to the current task.
					if (m_task_queue[task_idx].is_full())
					{
						// Recycle the buffers here.
						m_reference_buffer_store.recycle_buffers();

						// Process the current task.
						++task_id;
						auto &current_task(m_task_queue[task_idx]);
						current_task.m_task_id = task_id;
						current_task.m_status = project_task_status::processing;

						if (m_should_process_tasks_in_parallel)
							parallel_dispatch_queue.group_async(m_group, dispatch::task_from_member_fn <&project_task::process>(&current_task));
						else
							current_task.process();
				
						// Get an empty task.
						task_idx = m_task_queue.pop_index();
					}
			
					// Now there is guaranteed to be space in the current task.
					{
						auto &current_task(m_task_queue[task_idx]);
						libbio_assert(project_task_status::inactive == current_task.m_status.load());
				
#if 1
						using std::swap;
						swap(aln_rec, current_task.next_record());
#else
						current_task.next_record() = aln_rec; // Copy.
#endif

						current_task.m_last_rec_idx = rec_idx;
					}
				}
			
			finish:
				++rec_idx;
			}
		);
		
		// Finish the last task if needed.
		{
			auto &last_task(m_task_queue[task_idx]);
			if (!last_task.empty())
			{
				++task_id;
				last_task.m_task_id = task_id;
				last_task.m_status = project_task_status::processing;
				if (m_should_process_tasks_in_parallel)
					parallel_dispatch_queue.group_async(m_group, dispatch::task_from_member_fn <&project_task::process>(&last_task));
				else
					last_task.process();
			}
		}
		
		// When all the work in the group has been completed,
		// the record output blocks have already been inserted to the serial queue.
		if (m_should_process_tasks_in_parallel)
			m_group.notify(parallel_dispatch_queue, dispatch::task_from_member_fn <&input_processor::finish>(this));
		else
			finish();
	}


	void project_task::reset()
	{
		m_valid_records = 0;
		m_removed_tag_counts.clear();
		m_realigned_ranges.clear();
		m_realigned_range_count = 0;
		m_realignment_time = 0;
		m_realigned_range_total_length = 0;
	}
	
	
	void project_task::process()
	{
		auto const start_time(clock_type::now()); // For profiling.

		auto &output_header(m_input_processor->alignment_output().header);
		auto const &src_seq_entries(m_input_processor->src_seq_entries());
		auto const &dst_seq_entries(m_input_processor->dst_seq_entries());
		auto const &ref_ids(m_input_processor->alignment_input().header.reference_sequences);
		auto const &ref_id_separator(m_input_processor->reference_id_separator());
		auto const &ref_id_mapping(m_input_processor->reference_id_mapping());
		auto const &tag_identifiers(m_input_processor->sam_tag_identifiers());
		auto const &additional_preserved_tags(m_input_processor->additional_preserved_tags());
		auto const gap_opening_cost(m_input_processor->gap_opening_cost());
		auto const gap_extension_cost(m_input_processor->gap_extension_cost());
		auto const should_use_read_base_qualities(m_input_processor->should_use_read_base_qualities());
		auto const should_keep_duplicate_realigned_ranges(m_input_processor->should_keep_duplicate_realigned_ranges());
		auto const should_process_tasks_in_parallel(m_input_processor->should_process_tasks_in_parallel());

		libbio_assert_eq(0, m_realignment_time);
		libbio_assert_eq(0, m_realigned_range_count);
		
		// Process the records.
		// Try to be efficient by caching the previous pointer.
		std::stringstream oa_buffer;
		for (auto &aln_rec : alignment_records())
		{
			libbio_assert(project_task_status::processing == m_status.load());
			
			auto const ref_id(aln_rec.rname_id);
			libbio_assert_neq(sam::INVALID_REFERENCE_ID, ref_id);
			auto const dst_ref_id(ref_id_mapping[ref_id]);
			
			libbio_assert_lt(ref_id, src_seq_entries.size());
			libbio_assert_lt(dst_ref_id, dst_seq_entries.size());
			auto const &src_seq_entry(*src_seq_entries[ref_id]);
			auto const &dst_seq_entry(*dst_seq_entries[dst_ref_id]);
			
			// Rewrite the CIGAR and the position.
			auto const src_pos(aln_rec.pos);
			auto const &query_seq(aln_rec.seq);
			auto const &cigar_seq(aln_rec.cigar);
			auto const &ref_seq(m_input_processor->output_reference_sequence(dst_ref_id));
			libbio_assert(!ref_seq.empty());
			
			m_alignment_projector.reset();
			auto const dst_pos(m_alignment_projector.project_alignment(
				src_pos,
				src_seq_entry,
				dst_seq_entry,
				ref_seq,
				query_seq,
				cigar_seq,
				aln_rec.qual,
				gap_opening_cost,
				gap_extension_cost
			));
			libbio_always_assert_lte_(dst_pos, std::numeric_limits <sam::position_type_>::max());

			// Copy the realigned ranges.
			auto const &realn_ranges(m_alignment_projector.realigned_reference_ranges());
			auto const realn_range_count(realn_ranges.size());
			if (realn_range_count)
			{
				m_realigned_ranges.reserve(m_realigned_ranges.size() + realn_range_count);

				if (m_should_store_realigned_range_qnames)
				{
					for (auto const &range : realn_ranges)
						m_realigned_ranges.emplace_back(aln_rec.qname, range);
				}
				else
				{
					for (auto const &range : realn_ranges)
						m_realigned_ranges.emplace_back(range);
				}
				
				if (!should_keep_duplicate_realigned_ranges)
				{
					// Sort by the range and remove duplicates.
					std::sort(m_realigned_ranges.begin(), m_realigned_ranges.end());
					m_realigned_ranges.erase(std::unique(m_realigned_ranges.begin(), m_realigned_ranges.end()), m_realigned_ranges.end());
				}
			}
			
			{
				// Store the original NM value.
				auto const original_nm(aln_rec.optional_fields.template get <"NM"_tag>());
				
				// Remove the non-preserved tags.
				aln_rec.optional_fields.erase_if(
					[&additional_preserved_tags](auto const tag_rank){
						return !(
							std::binary_search(preserved_sam_tags.begin(), preserved_sam_tags.end(), tag_rank.tag_id) ||
							std::binary_search(additional_preserved_tags.begin(), additional_preserved_tags.end(), tag_rank.tag_id)
						);
					},
					[this](auto it, auto const end){
						while (it != end)
						{
							++m_removed_tag_counts[it->tag_id];
							++it;
						}
					}
				);
				
				// Store the original alignment.
				{
					// Clear the buffer.
					oa_buffer.str(std::string());
					oa_buffer.clear();
					
					// RNAME
					oa_buffer << ref_ids[ref_id] << ',';

					// POS
					oa_buffer << src_pos << ',';

					// Strand
					// FIXME: Some tools may determine from the minus sign that the sequence needs to be reverse-complemented, but this has already been taken into account?
					oa_buffer << (std::to_underlying(sam::flag::reverse_complemented & aln_rec.flag) ? '-' : '+') << ',';
					
					// CIGAR
					for (auto const cc : cigar_seq)
					{
						oa_buffer << cc.count();
						oa_buffer << cc.operation();
					}
					oa_buffer << ',';
					
					// MAPQ
					oa_buffer << +(aln_rec.mapq) << ',';
					
					// NM
					// The preceding comma is required even if the value is empty.
					if (original_nm)
						oa_buffer << *original_nm;
					
					// Trailing semicolon.
					oa_buffer << ';' << std::flush;
					
					// Copy to the end of OA.
					auto &oa_tag(aln_rec.optional_fields.template obtain <"OA"_tag>());
					oa_tag += oa_buffer.view();
				}
			}
			
			// Store the re-aligned ranges.
			auto output_realn_ranges([realn_range_count, &aln_rec](auto const &ranges, auto const tag){
				typedef std::vector <std::uint32_t> range_vector;
				range_vector output_ranges(2 * realn_range_count, 0);
				for (auto const &[idx, range] : rsv::enumerate(ranges))
				{
					auto const idx_(2 * idx);
					output_ranges[idx_] = range.location;
					output_ranges[idx_ + 1] = range.location + range.length;
				}
				aln_rec.optional_fields.template obtain <range_vector>(tag) = std::move(output_ranges);
			});
			if (tag_identifiers.realn_query_ranges && realn_range_count)
				output_realn_ranges(m_alignment_projector.realigned_query_ranges(), tag_identifiers.realn_query_ranges);
			if (tag_identifiers.realn_ref_ranges && realn_range_count)
				output_realn_ranges(m_alignment_projector.realigned_reference_ranges(), tag_identifiers.realn_ref_ranges);
			
			// Store the record index if needed.
			if (tag_identifiers.rec_idx)
			{
				auto const rec_idx(m_last_rec_idx - m_valid_records + 1);
				if (rec_idx <= INT32_MAX)
					aln_rec.optional_fields.template obtain <std::int32_t>(tag_identifiers.rec_idx) = rec_idx;
			}
			
			// Original reference ID.
			if (tag_identifiers.original_rname)
				aln_rec.optional_fields.template obtain <sam::reference_id_type_>(tag_identifiers.original_rname) = ref_id;
			
			// Original position.
			if (tag_identifiers.original_pos)
				aln_rec.optional_fields.template obtain <sam::position_type_>(tag_identifiers.original_pos) = src_pos;
			
			auto const rnext_id(aln_rec.rnext_id);
			if (sam::INVALID_REFERENCE_ID != rnext_id)
			{
				libbio_assert_lt(rnext_id, ref_id_mapping.size());
				auto const dst_rnext_id(ref_id_mapping[rnext_id]);
				aln_rec.rnext_id = dst_rnext_id;
				
				if (tag_identifiers.original_rnext)
					aln_rec.optional_fields.template obtain <sam::reference_id_type_>(tag_identifiers.original_rnext) = rnext_id;
				
				// Mate position.
				auto const pnext(aln_rec.pnext);
				if (sam::INVALID_POSITION != pnext)
				{
					auto const &src_seq_entry_(*src_seq_entries[rnext_id]);
					auto const &dst_seq_entry_(*dst_seq_entries[dst_rnext_id]);
					
					auto const dst_pnext(src_seq_entry_.project_position(pnext, dst_seq_entry_));
					aln_rec.pnext = dst_pnext;
					
					if (tag_identifiers.original_pnext)
						aln_rec.optional_fields.template obtain <sam::position_type_>(tag_identifiers.original_pnext) = pnext;
				}
			}
			else
			{
				// For extra safety.
				aln_rec.pnext = sam::INVALID_POSITION;
			}
			
			// Finally (esp. after setting OA/OC) update the CIGAR, the positions, and RNAME.
			aln_rec.pos = dst_pos;
			aln_rec.cigar = m_alignment_projector.alignment();
			aln_rec.rname_id = dst_ref_id;
		}

		{
			auto const end_time(clock_type::now()); // For profiling.
			auto const diff(end_time - start_time);
			m_execution_time = chrono::duration_cast <chrono::nanoseconds>(diff).count();
		}
		
		// Continue in the output queue.
		libbio_assert(project_task_status::processing == m_status.load());
		m_status = project_task_status::finishing;
		if (should_process_tasks_in_parallel)
		{
			auto &queue(m_input_processor->output_dispatch_queue());
			auto &group(m_input_processor->dispatch_group());
			queue.group_async(group, dispatch::task_from_member_fn <&project_task::output>(this));
		}
		else
		{
			output();
		}
	}


	void project_task::alignment_projector_end_realignment(panvc3::alignment_projector_base const &)
	{
		auto const pp(clock_type::now());
		auto const diff(pp - m_realignment_start_time);
		m_realignment_time += chrono::duration_cast <chrono::nanoseconds>(diff).count();
		++m_realigned_range_count;

		auto const &indel_run_checker(m_alignment_projector.indel_run_checker());
		auto const ref_range(indel_run_checker.reference_range()); // Has segment-relative position.
		auto const query_range(indel_run_checker.query_range());
		auto const length(std::max(ref_range.length, query_range.length));
		m_realigned_range_total_length += length;
	}
	
	
	void project_task::output()
	{
		// Now we are in the correct thread and also able to pass parameters to functions
		// without calling malloc, since we do not need to call via libdispatch.
		libbio_assert(project_task_status::finishing == m_status.load());
		m_input_processor->finish_task(*this);
	}
	
	
	void input_processor::finish_task(project_task &task)
	{
		// Not thread-safe; needs to be executed in a serial queue.
		
		libbio_assert(project_task_status::finishing == task.m_status.load());
		
		for (auto const &aln_rec : task.alignment_records())
		{
			libbio_assert(aln_rec.qual.empty() || aln_rec.seq.size() == aln_rec.qual.size());
			m_reference_buffer_store.release_buffer(aln_rec.rname_id);
			m_aln_output.output_record(aln_rec);
		}
		
		// Update the removed tag counts.
		// Could be done in O(m + n) time with a specialised merge instead of O(m log n) that we currently have.
		// (I don't think this is significant in any way.)
		for (auto const &kv : task.m_removed_tag_counts)
			m_removed_tag_counts[kv.first] += kv.second;
		
		// Handle the realigned ranges.
		auto const &task_realigned_ranges(task.m_realigned_ranges);
		if (m_realn_range_output.is_open())
		{
			if (m_should_keep_duplicate_realigned_ranges)
				output_realigned_ranges(task_realigned_ranges, task.m_task_id);
			else
			{
				// Merge in O(n + m) time since both vectors are already sorted.
				m_realigned_range_buffer.clear();
				m_realigned_range_buffer.reserve(m_realigned_ranges.size() + task_realigned_ranges.size());
				lb::sorted_set_union(m_realigned_ranges, task_realigned_ranges, std::back_inserter(m_realigned_range_buffer));
				
				using std::swap;
				swap(m_realigned_ranges, m_realigned_range_buffer);
			}
		}

		// Update statistics.
		m_realigned_range_count += task.m_realigned_range_count;
		m_realignment_time += task.m_realignment_time;
		m_realigned_range_total_length += task.m_realigned_range_total_length;
		m_task_execution_time_acc(task.m_execution_time);
		
		// Clean up.
		task.reset();
		task.m_status = project_task_status::inactive;
		m_task_queue.push(task);
	}
	
	
	void input_processor::output_realigned_ranges(realigned_range_vector const &ranges, std::size_t const task_id)
	{
		if (m_should_output_debugging_information)
		{
			if (m_should_keep_duplicate_realigned_ranges)
			{
				for (auto const &rr : ranges)
					m_realn_range_output << rr.range.location << '\t' << rr.range.length << '\t' << task_id << '\t' << rr.qname << '\n';
			}
			else
			{
				for (auto const &rr : ranges)
					m_realn_range_output << rr.range.location << '\t' << rr.range.length << '\t' << rr.qname << '\n';
			}
		}
		else
		{
			for (auto const &rr : ranges)
				m_realn_range_output << rr.range.location << '\t' << rr.range.length << '\n';
		}
	}
	
	
	void input_processor::finish()
	{
		m_aln_output.stream << std::flush;
		std::cout << std::flush;
		
		// Output the sorted realigned ranges if needed.
		if (m_realn_range_output.is_open())
		{
			if (!m_should_keep_duplicate_realigned_ranges)
				output_realigned_ranges(m_realigned_ranges);
			
			m_realn_range_output << std::flush;
		}
		
		lb::log_time(std::cerr) << "Done." << std::endl;
		
		// Output the statistics.
		std::cerr << "Matched reads:     " << m_statistics.matched_reads << '\n';
		std::cerr << "Ref. ID missing:   " << m_statistics.ref_id_missing << '\n';
		std::cerr << "Flags not matched: " << m_statistics.flags_not_matched << '\n';
		std::cerr << "Sequence missing:  " << m_statistics.seq_missing << '\n';
		
		if (m_realn_range_output.is_open() && !m_should_keep_duplicate_realigned_ranges)
			std::cerr << "Re-aligned ranges: " << m_realigned_ranges.size() << '\n';
		
		if (m_removed_tag_counts.empty())
			std::cerr << "No tags removed.\n";
		else
		{
			std::cerr << "Removed tags:\n";
			std::array <char, 3> buffer{'\0', '\0', '\0'};
			for (auto const &kv : m_removed_tag_counts)
			{
				sam::from_tag(kv.first, buffer);
				std::cerr << '\t' << buffer.data() << ": " << kv.second << '\n';
			}
		}
		
		// Clean up.
		(*m_exit_cb)();
	}
	
	
	std::unique_ptr <input_processor_base> s_input_processor;


	void do_exit()
	{
		s_input_processor.reset();
		dispatch::main_queue().stop();
	}


	void do_exit_async()
	{
		dispatch::main_queue().async(dispatch::task::from_lambda([](){ do_exit(); }));
	}


	void process_headers(
		sam::header const &aln_input_header,
		std::string const &ref_id_separator,
		std::string const &ref_seq_id,				// Projection target.
		char const * const ref_order_path,
		sam::header &aln_output_header,
		reference_id_mapping_type &ref_id_mapping	// From input to output.
	)
	{
		aln_output_header = sam::header::copy_subset <~sam::header::copy_selection_type::reference_sequences>(aln_input_header);
		
		ref_id_mapping.clear();
		ref_id_mapping.resize(aln_input_header.reference_sequences.size(), SIZE_MAX);
		
		// Parse the chromosome and sequence ids. (We need them in case the reference output order has been given.)
		std::vector <std::tuple <std::string_view, std::string_view>> input_ref_chr_seq_ids;
		input_ref_chr_seq_ids.reserve(aln_input_header.reference_sequences.size());
		for (auto const &input_ref : aln_input_header.reference_sequences)
		{
			std::string_view const input_ref_id(input_ref.name);
			auto const separator_pos(input_ref_id.find_first_of(ref_id_separator));
			if (std::string_view::npos == separator_pos)
			{
				std::cerr << "ERROR: Separator '" << ref_id_separator << "' not found in reference ID '" << input_ref_id << "'.\n";
				std::exit(EXIT_FAILURE);
			}
			
			auto const chr_id(input_ref_id.substr(0, separator_pos));
			auto const seq_id(input_ref_id.substr(1 + separator_pos));
			input_ref_chr_seq_ids.emplace_back(chr_id, seq_id);
		}
		
		{
			struct ref_id_pair
			{
				std::size_t input_index{};
				std::size_t output_index{};
			};
			
			std::map <std::string, ref_id_pair, lb::compare_strings_transparent> unique_ref_ids;
			typedef std::pair <std::size_t, bool> output_ref_name_value;
			std::unordered_map <
				std::string,
				output_ref_name_value,
				lb::string_hash_transparent,
				lb::string_equal_to_transparent
			> output_ref_name_order;
			
			if (ref_order_path)
			{
				// Get the distinct chromosome identifiers.
				std::set <std::string_view> unique_chr_ids;
				for (auto const &tup : input_ref_chr_seq_ids)
					unique_chr_ids.emplace(std::get <0>(tup));

				// Read the reference names.
				lb::file_istream stream;
				std::string buffer;
				
				lb::open_file_for_reading(ref_order_path, stream);
				std::size_t idx{};
				while (std::getline(stream, buffer))
				{
					std::string_view const buffer_(buffer);
					auto const ref_id(buffer_.substr(0, buffer_.find('\t'))); // Find the first tabulator if one exists; for handling .fai input.

					if (!unique_chr_ids.contains(ref_id))
					{
						std::cerr << "WARNING: Identifier ‘" << ref_id << "’ specified in reference name order but does not appear in the alignments.\n";
						continue;
					}

					auto const res(output_ref_name_order.emplace(ref_id, output_ref_name_value(idx, false)));
					if (!res.second)
					{
						std::cerr << "WARNING: Identifier ‘" << ref_id << "’ specified in reference name order more than once.\n";
						continue;
					}

					++idx;
				}
			}
			
			// Determine the unique reference identifiers by splitting by the separator and taking the left parts,
			// also number them.
			{
				std::size_t next_output_ref_idx{output_ref_name_order.size()};
				for (auto const &[input_ref_idx, tup] : rsv::enumerate(input_ref_chr_seq_ids))
				{
					auto const &[chr_id, seq_id] = tup;
					auto const it(unique_ref_ids.find(chr_id));
					std::size_t output_ref_idx{};
					if (unique_ref_ids.end() == it)
					{
						// Try to find chr_id in the user-specified order.
						auto const it(output_ref_name_order.find(chr_id));
						if (output_ref_name_order.end() == it)
						{
							output_ref_idx = next_output_ref_idx;
							++next_output_ref_idx;
							
							if (!output_ref_name_order.empty())
								std::cerr << "WARNING: Output reference ID ‘" << chr_id << "’ not found in the output order, placing in the end.\n";
						}
						else
						{
							auto &val(it->second);
							output_ref_idx = val.first;
							val.second = true; // Mark used.
						}
						
						unique_ref_ids.emplace(chr_id, ref_id_pair{input_ref_idx, output_ref_idx});
					}
					else
					{
						// chr_id already known.
						output_ref_idx = it->second.output_index;
					}
					
					ref_id_mapping[input_ref_idx] = output_ref_idx;
				}
			}
			
			// Copy the output reference identifiers to the header.
			aln_output_header.reference_sequences.resize(unique_ref_ids.size());
			for (auto &kv : unique_ref_ids)
			{
				auto const &ref_id(kv.second);
				auto output_ref(aln_input_header.reference_sequences[ref_id.input_index].copy_and_rename(std::move(kv.first)));
				aln_output_header.reference_sequences[ref_id.output_index] = std::move(output_ref);
			}
			aln_output_header.assign_reference_sequence_identifiers();
			
			// Check if there were any identifiers in the input that were not used.
			for (auto const &kv : output_ref_name_order)
			{
				auto const &val(kv.second);
				if (!val.second)
					std::cerr << "WARNING: Identifier ‘" << kv.first << "’ was given in the output reference name order but was not found in the input.\n";
			}
		}
	}


	void append_program_info(sam::header const &input_header, sam::header &output_header, int const argc, char const * const * const argv)
	{
		panvc3::append_sam_program_info(
			"panvc3.project-alignments.",
			"PanVC 3 project_alignments",
			argc,
			argv,
			CMDLINE_PARSER_VERSION,
			output_header.programs
		);
	}
	
	
	void fill_sequence_entries(
		panvc3::msa_index const &msa_index,
		sam::reference_sequence_entry_vector const &input_ref_ids,
		sam::reference_sequence_entry_vector const &output_ref_ids,
		std::string_view const ref_id_separator,
		std::string_view const reference_msa_id,
		reference_id_mapping_type const &ref_id_mapping,
		sequence_entry_ptr_vector &src_seq_entries,
		sequence_entry_ptr_vector &dst_seq_entries
	)
	{
		src_seq_entries.clear();
		dst_seq_entries.clear();
		src_seq_entries.resize(input_ref_ids.size(), nullptr);
		dst_seq_entries.resize(output_ref_ids.size(), nullptr);
		
		for (auto const &[input_ref_idx, ref] : rsv::enumerate(input_ref_ids))
		{
			std::string_view const ref_id(ref.name);
			auto const pos(ref_id.find(ref_id_separator));
			if (pos == std::string_view::npos)
			{
				std::osyncstream(std::cerr) << "ERROR: Unable to find the separator “" << ref_id_separator << "” in the RNAME “" << ref_id << "”." << std::endl;
				std::exit(EXIT_FAILURE);
			}
			
			auto const chr_id(ref_id.substr(0, pos));
			auto const src_seq_id(ref_id.substr(1 + pos));
			auto const output_ref_idx(ref_id_mapping[input_ref_idx]);
			
			auto const &chr_entry(find_chr_entry(msa_index.chr_entries, chr_id));
			
			libbio_assert_lt(output_ref_idx, dst_seq_entries.size());
			if (!dst_seq_entries[output_ref_idx])
			{
				auto const &dst_seq_entry(find_sequence_entry(chr_entry.sequence_entries, reference_msa_id));
				dst_seq_entries[output_ref_idx] = &dst_seq_entry;
			}
			
			libbio_assert_lt(input_ref_idx, src_seq_entries.size());
			libbio_assert_eq(src_seq_entries[input_ref_idx], nullptr);
			auto const &src_seq_entry(find_sequence_entry(chr_entry.sequence_entries, src_seq_id));
			src_seq_entries[input_ref_idx] = &src_seq_entry;
		}
	}


	void process(gengetopt_args_info const &args_info, int const argc, char const * const * const argv)
	{
		libbio_assert(args_info.ref_id_separator_arg);
		
		// Open the SAM input.
		auto aln_input{[&] -> alignment_input {
			if (args_info.alignments_arg)
				return alignment_input(lb::file_handle(lb::open_file_for_reading(args_info.alignments_arg)));
			else
				return alignment_input(lb::file_handle(STDIN_FILENO, false));
		}()};
		
		auto aln_output{[&] -> alignment_output {
			if (args_info.output_path_arg)
				return alignment_output(lb::file_handle(lb::open_file_for_writing(args_info.output_path_arg, lb::writing_open_mode::CREATE)));
			else
				return alignment_output(lb::file_handle(STDOUT_FILENO, false));
		}()};
		
		std::regex const tag_regex{"^[XYZ][A-Za-z0-9]$"};
		std::regex const any_tag_regex{"^[A-Za-z0-9]{2}$"};
		auto const make_sam_tag([&tag_regex, &any_tag_regex](char const *tag, bool const should_allow_any = false) -> panvc3::seqan3_sam_tag_type {
			if (!tag)
				return 0;

			if (!std::regex_match(tag, (should_allow_any ? any_tag_regex : tag_regex)))
			{
				std::cerr << "ERROR: The given tag '" << tag << "' does not match the expected format.\n";
				std::exit(EXIT_FAILURE);
			}

			std::array <char, 2> buffer{tag[0], tag[1]};
			return sam::to_tag(buffer);
		});

		std::string ref_id_separator(args_info.ref_id_separator_arg);
		std::string reference_msa_id(args_info.reference_msa_id_arg);

		// SAM tag identifiers.
		sam_tag_specification const tag_identifiers{
			.original_rname{make_sam_tag(args_info.original_rname_tag_arg)},
			.original_pos{make_sam_tag(args_info.original_pos_tag_arg)},
			.original_rnext{make_sam_tag(args_info.original_rnext_tag_arg)},
			.original_pnext{make_sam_tag(args_info.original_pnext_tag_arg)},
			.realn_query_ranges{make_sam_tag(args_info.realigned_query_ranges_tag_arg)},
			.realn_ref_ranges{make_sam_tag(args_info.realigned_ref_ranges_tag_arg)},
			.rec_idx{make_sam_tag(args_info.record_index_tag_arg)}
		};

		// Additional preserved SAM tags.
		panvc3::seqan3_sam_tag_vector additional_preserved_tags;
		for (unsigned int i(0); i < args_info.preserve_tag_given; ++i)
		{
			auto const tag_id(make_sam_tag(args_info.preserve_tag_arg[i], true));
			libbio_always_assert_neq(0, tag_id);
			additional_preserved_tags.push_back(tag_id);
		}
		std::sort(additional_preserved_tags.begin(), additional_preserved_tags.end());

		// Status output interval
		if (args_info.status_output_interval_arg < 0)
		{
			std::cerr << "ERROR: Status output interval must be non-negative.\n";
			std::exit(EXIT_FAILURE);
		}
		
		// Parse the SAM header.
		aln_input.reader.read_header(aln_input.header, aln_input.input_range);

		// Headers.
		reference_id_mapping_type ref_id_mapping;
		process_headers(
			aln_input.header,
			ref_id_separator,
			reference_msa_id,
			args_info.reference_order_input_arg,
			aln_output.header,
			ref_id_mapping
		);
		
		append_program_info(aln_input.header, aln_output.header, argc, argv);

		// Open the realigned range output file if needed.
		lb::file_handle realigned_range_handle;
		if (args_info.output_realigned_ranges_arg)
			realigned_range_handle = lb::file_handle(lb::open_file_for_writing(args_info.output_realigned_ranges_arg, lb::writing_open_mode::CREATE));
		
		// Load the MSA index.
		panvc3::msa_index msa_index;
		lb::log_time(std::cerr) << "Loading the MSA index…\n";
		{
			lb::file_istream stream;
			lb::open_file_for_reading(args_info.msa_index_arg, stream);
			cereal::PortableBinaryInputArchive archive(stream);
			archive(msa_index);
		}
		
		// Fill the MSA index entry tables.
		sequence_entry_ptr_vector src_seq_entries;
		sequence_entry_ptr_vector dst_seq_entries;
		fill_sequence_entries(
			msa_index,
			aln_input.header.reference_sequences,
			aln_output.header.reference_sequences,
			ref_id_separator,
			reference_msa_id,
			ref_id_mapping,
			src_seq_entries,
			dst_seq_entries
		);
		libbio_assert_eq(src_seq_entries.end(), std::find(src_seq_entries.begin(), src_seq_entries.end(), nullptr));
		libbio_assert_eq(dst_seq_entries.end(), std::find(dst_seq_entries.begin(), dst_seq_entries.end(), nullptr));
		
		// Load the reference sequences.
		lb::log_time(std::cerr) << "Loading the reference sequences…\n";
		panvc3::compressed_fasta_reader fasta_reader;
		fasta_reader.open_path(args_info.reference_arg);

		// Process the input.
		s_input_processor = std::make_unique <input_processor>(
			std::move(msa_index),
			std::move(src_seq_entries),
			std::move(dst_seq_entries),
			std::move(aln_input),
			std::move(aln_output),
			std::move(fasta_reader),
			std::move(realigned_range_handle),
			std::move(reference_msa_id),
			std::move(ref_id_separator),
			std::move(ref_id_mapping),
			std::move(additional_preserved_tags),
			tag_identifiers,
			args_info.gap_opening_cost_arg,
			args_info.gap_extension_cost_arg,
			args_info.status_output_interval_arg,
			args_info.verbose_status_output_flag,
			false, // args_info.primary_only_flag,
			args_info.use_read_base_qualities_flag,
			args_info.keep_duplicate_ranges_flag,
			args_info.debugging_output_flag,
			&do_exit_async
		);
		
		lb::log_time(std::cerr) << "Processing the alignments…\n";
		dispatch::main_queue().async(dispatch::task_from_member_fn <&input_processor_base::process_input>(s_input_processor.get()));
	}
}


extern "C" void panvc3_project_alignments(int argc, char **argv)
{
	gengetopt_args_info args_info;
	if (0 != cmdline_parser(argc, argv, &args_info))
		std::exit(EXIT_FAILURE);
	
	//lb::setup_allocated_memory_logging();

	std::ios_base::sync_with_stdio(false);	// Don't use C style IO after calling cmdline_parser.

	if (args_info.print_invocation_given)
	{
		std::cerr << "Invocation:";
		for (int i(0); i < argc; ++i)
			std::cerr << ' ' << argv[i];
		std::cerr << '\n';
	}

	if (args_info.print_pid_given)
		std::cerr << "PID: " << getpid() << '\n';
	
	process(args_info, argc, argv);
	
	dispatch::main_queue().run();
}
